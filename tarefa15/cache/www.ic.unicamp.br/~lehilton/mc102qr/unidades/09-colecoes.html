<!DOCTYPE html>

<html lang="pt-br">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    Algoritmos e Programação de Computadores
    - Coleções de dados
  </title>

  <meta name="keywords" content="MC102, Algoritmos e Programação de Computadores, Python">
  <meta name="description" content="Página da disciplina de MC102 para turma QR">
  <meta name="author" content="Lehilton Pedrosa">

  <!-- Bootstrap core CSS -->
  <link href="../dist/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Theme css -->
  <link href="../dist/css/main.min.css" rel="stylesheet">

  <!-- Prism -->
  <!-- <link href="../dist/vendor/prism/prism.css" rel="stylesheet" /> -->
</head>
<body >

  <body>

<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="../index.html">MC102</a>


    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i>&#9776;</i>
    </button>

    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">

        <li class="nav-item top back-to-top-link">
          <a class="nav-link" href="#"><span class="glyphicon glyphicon-align-left" aria-hidden="true"></span>topo</a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="../index.html">voltar</a>
        </li>


      </ul>
    </div>
  </div>
</nav>

<!-- Page Header -->
<header class="masthead"   style="background-image: url('../images/home-bg.jpg')" >
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <div class="post-heading">

          <h1 >Coleções de dados</h1>


          <span class="meta">Quinta, 21 de maio de 2020</span>

        </div>
      </div>
    </div>
  </div>
</header>
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">


      <div class="col-lg-8 col-md-10 mx-auto">

        <p><strong>Instruções</strong>: Para essa unidade, você deve ler as seções 5.3 a 5.6
do <a href="https://docs.python.org/pt-br/3/tutorial/index.html">tutorial</a>
Python. Só leia a seção de classes do tutorial depois que estiver
confortável com os conceitos de conjuntos e dicionários. Quando se
sentir pronto, leia a seção 9 até a subseção 9.4.</p>
<p>Para guardar dados na memória do computador, quase sempre utilizamos
variáveis ou listas de variáveis de tipos básicos. Como não tínhamos
muitas opções, não nos preocupávamos com a forma com que os dados eram
armazenados. Nesta unidade, veremos que as escolhas que fazemos para
representar dados na memória têm consequências importantes para os
algoritmos que lemos e escrevemos. Essas consequências são percebidas
tanto quando queremos dar significado aos dados, quanto quando
queremos executar algum algoritmo.</p>
<p>Iremos falar de dois conceitos que devem acompanhar uma programadora
durante toda a vida: <strong>abstração</strong> e <strong>representação</strong>. Desde que
começamos a falar de algoritmos, vimos que preferimos falar de bytes
ao invés de bits, de palavras ao invés de sequência de caracteres e
assim por diante. Enquanto um computador só manipula dados (ou bits,
em última instância), nos nossos algoritmos, preferimos falar de
objetos mais próximos do nosso cotidiano. Assim, queremos falar de
estudantes, ao invés de um número de RA associado a um nome. Nesse
caso, criamos uma abstração para um estudante que é representada em
memória por um inteiro e uma string.</p>
<p>O dados que precisamos armazenar para uma determinada abstração
dependem do problema. Por exemplo, se queremos descobrir se um
estudante foi aprovado, uma prova poderia muito bem ser representada
por um número de ponto flutuante correspondente à nota. Se quisermos
calcular a nota da prova em si, então provavelmente representaríamos a
prova como uma lista de números correspondente às questões. A
representação de uma abstração corresponde tanto à lista de dados que
armazenamos na memória bem como a forma com que esses dados estão
organizados.</p>
<p>Por exemplo, no momento da inscrição em uma universidade, cada
estudante precisa preencher um fomulário. Esse formulário é uma tabela
padronizada com espaço reservado para vários campos, como nome, data
de nascimento, endereço etc. Nesse exemplo, a representação é o
leiaute do formulário. Já cada cópia do formulário preenchida
corresponde a um objeto ou indivíduo de nossa abstração &quot;estudante&quot;.
Nem todo conjunto de dados compatível com a representação corresponde
a um indivíduo da abstração, afinal, não basta preencher um formulário
de inscrição para ser universitário. Similarmente, nem todo trio de
números inteiros corresponde a uma data.</p>
<p>Os dados sozinhos não servem para muita coisa se não tivermos o que
fazer com eles. Assim, além da forma com que os dados são armazenados,
também precisamos de uma lista de operações que permitem acessá-los e
modificá-los. De maneira mais ampla, chamamos de <strong>estrutura de
dados</strong> o conjunto de regras e convenções que definem a representação
de uma abstração associado a uma lista de operações permitidas.</p>
<p>A primeira vez que utilizamos uma abstração razoavelmente sofisticada
e que não fosse um tipo padrão de Python foi quando estudamos
matrizes. Naquele momento, representamos uma matriz como uma lista de
listas de escalares. Poderíamos também ter representado uma matriz
como uma única lista de escalares, lidos da esquerda para direita e de
cima para baixo. A razão para escolhermos listas de listas é que essa
organização facilita bastante a operação mais comum de uma matriz:
acessar um determinado elemento.</p>
<p>A escolha ou o projeto de uma estrutura de dados não é tarefa trivial
e não é nosso objetivo aprender a projetar estruturas de dados
avançadas — há uma disciplina só para isso. Por enquanto, o que é
importante é entender que cada estrutura de dados é projetada para
executar bem e eficientemente um conjunto próprio de operações. Assim,
para escolher uma estrutura de dados, vamos comparar as operações de
que precisamos com as operações que cada estrutura de dados que
conhecemos oferece. Isso não é fácil. Não vou mentir.</p>
<h2 id="colecoes-dinamicas-de-dados">Coleções dinâmicas de dados</h2>
<p>Em diversos dos problemas que queremos resolver com um computador,
precisamos lidar com uma grande quantidade de dados. Ter muitos dados
implica que que precisamos tratar a maioria deles de maneira uniforme,
já que não podemos escrever um algoritmo para cada indivíduo. Assim,
vamos imaginar que o conjunto de dados de entrada de nosso problema
corresponde a uma coleção que cada elemento dessa coleção é um
indivíduo da mesma abstração.</p>
<p>Muitas vezes as coleções de dados são dinâmicas, i.e., elas mudam com o tempo.
As operações que podemos fazer sobre coleções dinâmicas são variadas, mas quase sempre queremos pelos menos</p>
<ul>
<li>inserir um novo elemento;</li>
<li>buscar ou alterar um elemento existente;</li>
<li>remover um elemento existente.</li>
</ul>
<p>Até então, estudamos coleções dinâmicas bem simples: listas de
inteiros, listas de strings, etc. Dessa vez, vamos falar de uma
coleção de objetos mais elaborados.</p>
<blockquote>
<p>Considere um dicionarista. Ele é responsável estudar e investigar um
conjunto de palavras. Ele pode catalogar novas palavras, alterar a
definição de palavras existentes... Como representar o dicionário
manipulado por ele?</p>
</blockquote>
<p>Normalmente, sempre falamos de um problema com entrada e saída bem
definidas. Nesse caso, não temos uma entrada nem saída, mas falamos
das <strong>operações</strong> que desejamos realizar com uma coleção de dados. O
motivo é que queremos criar uma estrutura de dados que possa ser
utilizada pelo dicionarista em diversas situações.</p>
<p>Primeiro, precisamos listar que dados precisamos guardar. Ora, os
dados que precismos guardar são as palavras do idioma. O problema é
que Python não tem ideia do que é uma palavra — aliás, Python não tem
ideia nenhuma, apenas tipos. Podemos dizer então que uma palavra é uma
string. Mas isso seria desvalorizar o trabalho do dicionarista, que
pesquisa a definição de cada uma palavra. Então vamos guardar também a
definição da palavra. Mas e o ano em que a palavra foi catalogada pela
primeira vez? Também é importante conhecer a história das palavras.</p>
<p>O fato é que, associado a uma palavra, há um conjunto enorme de outras
informações e qualquer subconjunto pequeno de dados que escolhermos
não irá representar uma palavra em sua plenitude. Por isso, iremos
omitir todos os dados que não interessam à nossa aplicação. Pode ser
que esse dicionarista em particular esteja interessado apenas na
palavra, na definição e no ano em que ela foi catalogada. Uma palavra
e sua definição são facilmente representadas por strings e o ano, é
claro, por um inteiro, como 2020. Hum... não seria tão claro assim se
você tivesse nascido no
<a href="https://pt.wikipedia.org/wiki/Problema_do_ano_2000">milênio passado</a>.</p>
<p>Agora podemos pensar no dicionário. Queremos armazenar uma lista de
palavras, então uma escolha óbvia parece ser uma lista de strings
<code class="language-text">palavras</code>. Do mesmo modo, criamos uma lista de strings <code class="language-text">definicoes</code>
para representar as definições e uma lista de inteiros <code class="language-text">anos</code> para
representar os anos. Portanto, uma palavra <code class="language-text">palavras[i]</code> teria sido
catalogada no ano <code class="language-text">anos[i]</code> e assim por diante. Isso é suficiente para
guardar todos os dados de nossa aplicação, mas é uma péssima escolha
de estrutura de dados. O motivo é que uma regra de ouro das estruturas
de dados diz que dados relacionados devem andam juntos. Imagine, por
exemplo, o que acontece se quisermos ordenar a lista de palavras
alfabeticamente. Dá nervoso só de pensar.</p>
<p>Como vimos matrizes recentemente, é tentador remediar a situação e
dizer que devemos representar um dicionário como uma matriz dos dados.
Afinal, o que queremos representar é uma tabela de dados. Digamos
então que <code class="language-text">dicionario</code> é uma matriz, isso é, uma lista de listas. Isso
é definitivamente muito melhor do que a representação anterior, mas
tampouco é uma boa escolha. Uma razão é que chamamos de matriz uma
estrutura bidimensional de dados escalares do mesmo tipo, mas um
inteiro representando um ano é bem distinto de uma string
representando uma definição. Outra razão é que não é claro o que
significa uma entrada da matriz <code class="language-text">dicionario[i][j]</code>. Seria o <code class="language-text">j</code>-ésimo
dado da <code class="language-text">i</code>-ésima palavra, ou seria o <code class="language-text">i</code>-ésimo dado da <code class="language-text">j</code>-ésima
palavra? Em uma matriz, não há motivo nenhum para preferir uma forma a
outra.</p>
<p>Na verdade, um dicionário é uma coleção de verbetes, então seria muito
melhor representá-lo como uma lista de verbetes — mas, ao contrário de
uma palavra que pode ser facilmente representada por uma string, não
há tipo nativo em Python que corresponda a um verbete. Isso sugere que
devamos criar nossa própria abstração para representar um verbete. Um
verbete consiste de exatamente três dados distintos, a palavra, a
definição e o ano, então é natural representá-lo como uma tupla:</p>
<pre class="highlight">(palavra, definição, ano)
</pre><p>Uma tupla é parecida com a uma lista, mas não podemos adicionar ou
remover elementos, nem mudar os objetos a que ela se refere.
Poderíamos dizer também que um verbete é uma lista
<code class="language-text">[palavra, definicao, ano]</code>, mas há algumas vantagens em utilizar uma
tupla. Como a tupla é imutável, comunicamos claramente que há três, e
só três, dados em um verbete. Também, como já discutimos, preferimos
trabalhar com listas cujos elementos tenham o mesmo tipo e o mesmo
significado. O fato de não podermos modificar os objetos a que uma
tupla se refere pode ser uma desvantagem, mas é uma vantagem nesse
exemplo: não queremos que um verbete lido seja alterado pelo seu
usuário (da mesma forma que não queremos adulterar os livros
emprestados de uma biblioteca).</p>
<img src="figs/lista_tuplas.png" style="width: 100%; max-width: 500px;">
<p>Para deixar o exemplo um pouco mais concreto e para exemplificar como
o dicionarista poderia utilizar a estrutura de dados, suponha que ele
deseja fazer uma sequencia de operações que inclui criar um
dicionário, adicionar um verbete, buscar um verbete e alterar a
definição de um verbete.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    dicionario <span style="color: #666666">=</span> criar_dicionario()

    verbete <span style="color: #666666">=</span> (<span style="color: #BA2121">&quot;amor&quot;</span>, <span style="color: #BA2121">&quot;fogo que arde sem se ver&quot;</span>, <span style="color: #666666">1595</span>)
    adicionar_verbete(dicionario, verbete)

    verbete <span style="color: #666666">=</span> procurar_verbete(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>)
    palavra, definicao, ano <span style="color: #666666">=</span> verbete
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;</span><span style="color: #BB6688; font-weight: bold">{palavra}</span><span style="color: #BA2121"> significa </span><span style="color: #BB6688; font-weight: bold">{definicao}</span><span style="color: #BA2121">&quot;</span>)

    nova_definicao <span style="color: #666666">=</span> <span style="color: #008000">input</span>(<span style="color: #BA2121">&quot;O que você acha que é o amor?</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)
    atualizar_definicao(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>, nova_definicao)

    palavra, definicao, ano <span style="color: #666666">=</span> procurar_verbete(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;</span><span style="color: #BB6688; font-weight: bold">{palavra}</span><span style="color: #BA2121"> agora significa </span><span style="color: #BB6688; font-weight: bold">{definicao}</span><span style="color: #BA2121">&quot;</span>)
</pre><p>Primeiro, vamos nos concentrar em criar um dicionário e adicionar um
verbete.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">criar_dicionario</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;cria um dicionário vazio&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">return</span> []

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">adicionar_verbete</span>(dicionario, verbete):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;adiciona um novo verbete ao dicionário&quot;&quot;&quot;</span>

    dicionario<span style="color: #666666">.</span>append(verbete)
</pre><p>Pode parecer bobagem criar uma função apenas pare devolver uma lista
vazia, ou só para adicionar em elemento no final da lista, mas não é.
Mesmo programadores experientes podem dizer que bastaria ter criado
uma lista vazia na função <code class="language-text">main</code>. Não dê ouvido a eles. Há algumas
razões importantes para termos criado essas funções. Por exemplo, é
mais claro escrever <code class="language-text">dicionario = criar_dicionario()</code> para dizer que
estamos criando um novo indivíduo da abstração &quot;dicionário&quot; do que
escrever <code class="language-text">dicionario = []</code>. Mais importante do que isso, quando
escrevemos <code class="language-text">dicionario = []</code>, temos que nos preocupar em como um
dicionário está representado na memória, mas é exatamente isso que
nossa abstração está tentando esconder.</p>
<p>Vamos agora implementar a busca e a atualização de um verbete.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">procurar_verbete</span>(dicionario, palavra):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;devolve o verbete correspondente à palavra;</span>
<span style="color: #BA2121; font-style: italic">    se palavra não for encontrada, devolve None&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">for</span> verbete <span style="color: #AA22FF; font-weight: bold">in</span> dicionario:
        <span style="color: #008000; font-weight: bold">if</span> verbete[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> palavra:
            <span style="color: #008000; font-weight: bold">return</span> verbete
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">atualizar_definicao</span>(dicionario, palavra, nova_definicao):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;atualiza a definição de uma palavra&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">for</span> verbete <span style="color: #AA22FF; font-weight: bold">in</span> dicionario:
        <span style="color: #008000; font-weight: bold">if</span> verbete[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> palavra:
            verbete[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> nova_definicao
</pre><p>Na função <code class="language-text">procurar_verbete</code>, usamos <code class="language-text">None</code>, que é um valor especial
em Python para representar ausência. Mas a implementação acima está
errada. O motivo é que não podemos alterar tuplas. Você pode pensar
nisso como uma desvantagem, mas imagine se alguma outra função tivesse
um verbete e o alterasse ignorando que ele é parte do dicionário. Essa
função estaria alterando o dicionário, então qualquer outra função que
buscasse por esse verbete no dicionário iria ser afetada pela
alteração. Muito provavelmente, isso causaria um bug muito difícil de
encontrar. Para poder atualizar o dicionário então, precisamos
substituir o verbete por um novo, mas para alterar um elemento
referenciado por uma lista, precisamos do índice correspondente.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">procurar_indice</span>(dicionario, palavra):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;devolve o índice correspondente à palavra</span>
<span style="color: #BA2121; font-style: italic">    ou None se ela não existir no dicionário&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">for</span> i, verbete <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dicionario):
        <span style="color: #008000; font-weight: bold">if</span> verbete[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> palavra:
            <span style="color: #008000; font-weight: bold">return</span> i
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">atualizar_definicao</span>(dicionario, palavra, nova_definicao):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;atualiza a definição de uma palavra&quot;&quot;&quot;</span>

    i <span style="color: #666666">=</span> procurar_indice(dicionario, palavra)
    verbete_antigo <span style="color: #666666">=</span> dicionario[i]
    verbete_novo <span style="color: #666666">=</span> (verbete_antigo[<span style="color: #666666">0</span>], nova_definicao, verbete_antigo[<span style="color: #666666">2</span>])
    dicionario[i] <span style="color: #666666">=</span> verbete_novo
</pre><p>Para o interpretador Python, <code class="language-text">dicionario</code> é só mais uma lista, então
ele não se importaria se o dicionarista escrevesse a função abaixo.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    dicionario <span style="color: #666666">=</span> criar_dicionario()

    verbete <span style="color: #666666">=</span> (<span style="color: #BA2121">&quot;amor&quot;</span>, <span style="color: #BA2121">&quot;fogo que arde sem se ver&quot;</span>, <span style="color: #666666">1595</span>)
    adicionar_verbete(dicionario, verbete)

    outro <span style="color: #666666">=</span> (<span style="color: #BA2121">&quot;amor&quot;</span>, <span style="color: #BA2121">&quot;é sofrer amargamente&quot;</span>, <span style="color: #666666">2020</span>)
    adicionar_verbete(dicionario, outro)

    palavra, definicao, _ <span style="color: #666666">=</span> procurar_verbete(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;</span><span style="color: #BB6688; font-weight: bold">{palavra}</span><span style="color: #BA2121"> significa </span><span style="color: #BB6688; font-weight: bold">{definicao}</span><span style="color: #BA2121">&quot;</span>)
</pre><p>Teríamos um dicionário com dois verbetes correspondendo à mesma
palavra. Não parece algo muito confiável: quando alguém procurar por
uma palavra, qual definição seria devolvida? Nesse caso, a função
<code class="language-text">procurar_verbete</code> percorre a lista do início ao fim, então ela
devolveria a primeira definição. Uma outra implementação poderia
devolver a segunda definição e ainda assim cumprir o combinado em sua
documentação.</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> python3 dicionario_tuplas.py
<span style="color: #888888">amor significa fogo que arde sem se ver</span>
</pre><p>Onde está o erro? Deve estar na função <code class="language-text">procurar_verbete</code>, ou na
função <code class="language-text">main</code>. Nesse caso, está na função main, então o dicionarista
deveria certificar-se de que a palavra não está no dicionário antes de
adicioná-la. Mas isso é pedir demais a ele. A função que realmente
deixou a nossa representação na memória inconsistente foi
<code class="language-text">adicionar_verbete</code>. Seria muito bom se, quando o dicionarista
tentasse adicionar um verbete para uma palavra existente, o
informássemos desse erro.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">adicionar_verbete</span>(dicionario, verbete):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;adiciona um novo verbete ao dicionário&quot;&quot;&quot;</span>

    i <span style="color: #666666">=</span> procurar_indice(dicionario, verbete[<span style="color: #666666">0</span>])
    <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        dicionario<span style="color: #666666">.</span>append(verbete)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">Exception</span>(<span style="color: #BA2121">f&quot;Palavra </span><span style="color: #BB6688; font-weight: bold">{verbete[0]}</span><span style="color: #BA2121"> já existe.&quot;</span>)
</pre><p>Há mais uma novidade aqui. A instrução <code class="language-text">raise Exception(...)</code> serve
para criar uma nova exceção sinalizando um erro. Já lidamos com
exceções antes; o que há de diferente aqui é que, dessa vez, nós
criamos nosso próprio erro. Assim, quando o dicionarista executar a
função <code class="language-text">main</code> com problemas, a execução do programa será interrompida
no momento em que ele tentasse adicionar um verbete para uma palavra
que já está no dicionário.</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> python3 dicionario_tuplas.py
<span style="color: #888888">Traceback (most recent call last):</span>
<span style="color: #888888">  File &quot;dicionario_tuplas.py&quot;, line 69, in &lt;module&gt;</span>
<span style="color: #888888">    main()</span>
<span style="color: #888888">  File &quot;dicionario_tuplas.py&quot;, line 53, in main</span>
<span style="color: #888888">    adicionar_verbete(dicionario, outro)</span>
<span style="color: #888888">  File &quot;dicionario_tuplas.py&quot;, line 14, in adicionar_verbete</span>
<span style="color: #888888">    raise Exception(f&quot;Palavra {verbete[0]} já existe.&quot;)</span>
<span style="color: #888888">Exception: Palavra amor já existe.</span>
</pre><p>Há vários tipos de exceção, como <code class="language-text">ValueError</code>, <code class="language-text">IndexError</code>,
<code class="language-text">ZeroDivisionError</code> e podemos criar a nossa própria hierarquia de
tipos. Nesta disciplina é suficiente utilizar um tipo de erro genérico
e levantar uma exceção. Para isso, basta fazer uma chamada a
<code class="language-text">Exception</code> passando a mensagem de erro como argumento. Você deveria
ter se convencido de que criar uma função apenas para adicionar um
elemento à lista não é tão bobo assim.</p>
<p>Uma operação sobre a qual não discutimos é a remoção de um verbete.
Pode ser que uma palavra se torne obsoleta, então, embora incomum,
essa é uma operação que o dicionarista desejaria realizar. Implemente
a operação para remover um verbete.</p>
<h1 id="conjuntos">Conjuntos</h1>
<p>Em uma lista, temos uma sequência de elementos, ou seja, existe a
noção de primeiro elemento, de segundo etc. Enquanto lista é o tipo em
Python mais comum para representar coleções de dados, muitas vezes a
ordem em que eles estão armazenados é irrelevante. Isso acontece
quando falamos de conjuntos, no sentido matemático: não existe uma
ordem dos elementos e nenhum elemento aparece mais do que uma vez.</p>
<blockquote>
<p>Escreva uma função que receba dois conjuntos de strings e devolva a
diferença entre esses conjuntos.</p>
</blockquote>
<p>Não é muito difícil escrever um algoritmo para esse problema e depois
programá-lo.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_diferenca</span>(a, b):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;recebe conjuntos a e b e devolve a - b&quot;&quot;&quot;</span>

    diferenca <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> elemento_a <span style="color: #AA22FF; font-weight: bold">in</span> a:
        <span style="color: #008000; font-weight: bold">if</span> elemento_a <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> b:
            diferenca<span style="color: #666666">.</span>append(elemento_a)
    <span style="color: #008000; font-weight: bold">return</span> diferenca

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    a <span style="color: #666666">=</span> [<span style="color: #BA2121">&quot;ana&quot;</span>, <span style="color: #BA2121">&quot;maria&quot;</span>, <span style="color: #BA2121">&quot;pedro&quot;</span>, <span style="color: #BA2121">&quot;raul&quot;</span>]
    b <span style="color: #666666">=</span> [<span style="color: #BA2121">&quot;sérgio&quot;</span>, <span style="color: #BA2121">&quot;gustavo&quot;</span>, <span style="color: #BA2121">&quot;maria&quot;</span>, <span style="color: #BA2121">&quot;ana&quot;</span>]
    diferenca <span style="color: #666666">=</span> calcular_diferenca(a, b)
    <span style="color: #008000">print</span>(diferenca)
</pre><p>Esse é só um exemplo. Não precisávamos de um computador para descobrir
que a diferença desses conjuntos corresponde a <code class="language-text">[&quot;pedro&quot;, &quot;raul&quot;]</code>. Os
computadores são mais úteis quando trabalhamos com grandes volumes de
dados.</p>
<p>Você já deve ter ouvido falar que português e espanhol são muito
parecidos. É bem possível que você entenda uma pessoa falando espanhol
— se ela falar bem devagar, mesmo que nunca tenha estudado o idioma.
Vamos tirar isso a prova e calcular a diferença das 1000 palavras mais
comuns dos dois idiomas.</p>
<p>Primeiro, com um pouco de paciência, precisamos encontrar duas listas
razoavelmente confiáveis de palavras frequentes em português e
espanhol. Você pode achar dois arquivos <code class="language-text">pt_br.txt</code> e <code class="language-text">es.txt</code>
<a href="https://invokeit.wordpress.com/frequency-word-lists/">aqui</a>. Vamos
investigar um pouco esses arquivos de texto olhando para as primeiras
linhas.</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> ls -lh *.txt
<span style="color: #888888">-rw-rw-r-- 1 user user 6,6M set 25  2013 es.txt</span>
<span style="color: #888888">-rw-rw-r-- 1 user user 4,8M set 25  2013 pt_br.txt</span>
<span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> head pt_br.txt
<span style="color: #888888">que 3097124</span>
<span style="color: #888888">não 2582821</span>
<span style="color: #888888">o 2582602</span>
<span style="color: #888888">de 2075204</span>
<span style="color: #888888">a 1948955</span>
<span style="color: #888888">é 1786757</span>
<span style="color: #888888">você 1513922</span>
<span style="color: #888888">e 1508432</span>
<span style="color: #888888">eu 1416433</span>
<span style="color: #888888">um 1197384</span>
<span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> head es.txt
<span style="color: #888888">de 3405234</span>
<span style="color: #888888">que 3349162</span>
<span style="color: #888888">no 3166057</span>
<span style="color: #888888">a 2368719</span>
<span style="color: #888888">la 2288023</span>
<span style="color: #888888">el 1922428</span>
<span style="color: #888888">y 1774259</span>
<span style="color: #888888">es 1729448</span>
<span style="color: #888888">en 1640089</span>
<span style="color: #888888">lo 1429314</span>
</pre><p>O comando <code class="language-text">head</code> mostra as primeiras dez linhas de um arquivo. Você
não quer abrir um arquivo com vários megabytes em um editor de textos,
acredite. Agora podemos fazer um programa que leia as palavras mais
frequêntes de cada idioma e calcule a diferença.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ler_palavras_frequentes</span>(nome_arquivo, n):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;lê o arquivo de frequência de palavras</span>
<span style="color: #BA2121; font-style: italic">    e devolve as n palavras mais frequentes&quot;&quot;&quot;</span>

    lista <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(nome_arquivo) <span style="color: #008000; font-weight: bold">as</span> arquivo:
        i <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> linha <span style="color: #AA22FF; font-weight: bold">in</span> arquivo:
            palavra, frequencia <span style="color: #666666">=</span> linha<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>split()
            lista<span style="color: #666666">.</span>append(palavra)
            i <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">==</span> n:
                <span style="color: #008000; font-weight: bold">break</span>
    <span style="color: #008000; font-weight: bold">return</span> lista

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_diferenca</span>(a, b):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;recebe conjuntos a e b e devolve a - b&quot;&quot;&quot;</span>

    diferenca <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> elemento_a <span style="color: #AA22FF; font-weight: bold">in</span> a:
        <span style="color: #008000; font-weight: bold">if</span> elemento_a <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> b:
            diferenca<span style="color: #666666">.</span>append(elemento_a)
    <span style="color: #008000; font-weight: bold">return</span> diferenca

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">mostrar_lista</span>(lista):
    <span style="color: #008000; font-weight: bold">for</span> elemento <span style="color: #AA22FF; font-weight: bold">in</span> lista:
        <span style="color: #008000">print</span>(elemento)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    n <span style="color: #666666">=</span> <span style="color: #666666">10</span>
    palavras_es <span style="color: #666666">=</span> ler_palavras_frequentes(<span style="color: #BA2121">&#39;es.txt&#39;</span>, n)
    palavras_pt_br <span style="color: #666666">=</span> ler_palavras_frequentes(<span style="color: #BA2121">&#39;pt_br.txt&#39;</span>, n)
    diferenca <span style="color: #666666">=</span> calcular_diferenca(palavras_es, palavras_pt_br)
    mostrar_lista(diferenca)

main()
</pre><p>Para testar, começamos comparando as 10 palavras mais frequentes
de cada idioma.</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> python3 diferenca.py
<span style="color: #888888">no</span>
<span style="color: #888888">la</span>
<span style="color: #888888">el</span>
<span style="color: #888888">y</span>
<span style="color: #888888">es</span>
<span style="color: #888888">en</span>
<span style="color: #888888">lo</span>
</pre><p>Bueno. Não há tanta interseção assim com as 10 palavras mais
frequentes do espanhol, então precisamos de fato aprender quase todas.
O lado bom é que são palavras fáceis. Vamos contar quantas palavras
novas precisamos aprender se quisermos conhecer as 1000 mais
frequentes do espanhol. Como só estamos interessados na contagem,
vamos substituir a instrução <code class="language-text">mostrar_lista(diferenca)</code> por algo como
<code class="language-text">print(f&quot;Queremos aprender {len(diferenca)} palavras.&quot;)</code>. Executando
para <code class="language-text">n = 1000</code>, obtemos a saída quase que imediatamente.</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> python3 diferenca.py
<span style="color: #888888">Queremos aprender 742 palavras.</span>
</pre><p>Pelo menos não são todas as 1000 palavras. Para alguém que nasceu
antes dos computadores se popularizarem, parece um grade feito
calcular a diferença entre conjuntos de 1000 palavras em tão pouco
tempo — em algumas dezenas de milissegundos. Para quem já nasceu com
um computador na mão, isso não tem nada de impressionante. Vamos
tentar com 100.000 palavras. Alteramos a função fazendo <code class="language-text">n = 100000</code>,
salvamos e executamos novamente. Execute você mesmo, não acredite em
tudo que lê!</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> python3 diferenca.py
<span style="color: #888888">Queremos aprender 57529 palavras.</span>
</pre><p>No meu computador, essa execução levou cerca de um minuto e meio! Isso
é muito tempo para os padrões atuais. Então precisamos parar e pensar:
por que o programa gastou tanto tempo? Será que os computadores de
hoje em dia não são rápidos para um problema desse tipo? Com certeza
você já viu tarefas muito mais complicadas serem realizadas por um
computador em muito menos tempo, então temos que desconfiar de nosso
algoritmo.</p>
<p>Quando estamos numa situação como essa, temos que descobrir quais
instruções de nosso programa são executadas mais vezes. Revise o
programa e tente descobrir quais instruções são executadas mais vezes.
Você deve se convencer de que uma delas é a instrução <code class="language-text">in</code> na linha
que contém <code class="language-text">if elemento not in b:</code>. Essa instrução é executada 100.000
vezes, uma vez para cada palavra frequente em espanhol. Mas meu
computador executa milhões de instruções elementares por segundo,
então para realmente entender porque o programa gastou tanto tempo
vamos reescrever essa linha explicitando o que o interpretador python
tem que fazer sempre que a executa.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_diferenca</span>(a, b):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;recebe conjuntos a e b e devolve a - b&quot;&quot;&quot;</span>

    diferenca <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> elemento_a <span style="color: #AA22FF; font-weight: bold">in</span> a:
        encontrou <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>
        <span style="color: #008000; font-weight: bold">for</span> elemento_b <span style="color: #AA22FF; font-weight: bold">in</span> b:
            <span style="color: #008000; font-weight: bold">if</span> elemento_a <span style="color: #666666">==</span> elemento_b:
                encontrou <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
                <span style="color: #008000; font-weight: bold">break</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> encontrou:
            diferenca<span style="color: #666666">.</span>append(elemento_a)
    <span style="color: #008000; font-weight: bold">return</span> diferenca
</pre><p>Como representamos o conjunto de palavras usando uma lista, para
encontrar uma determinada palavra na lista, temos que percorrê-la
desde o início, não há outro jeito. Pior, no nosso exemplo, em 57.529
da vezes que procuramos alguma palavra, tivemos que percorrer <em>toda</em> a
lista de palavras em português, só para descobrir que a palavra em
espanhol não estava ali.</p>
<p>A escolha da representação do nosso conjunto de dados nesse caso teve
um impacto tremendo no tempo de execução do algoritmo. Listas foram
feitas para armazenar conjuntos de dados que são acessados
sequencialmente na ordem armazenada --- elas não são boas para
procurar valores arbitrários. Por esse motivo, existe um outro tipo de
coleção de dados para representar conjuntos, o <code class="language-text">set</code>. A vocação de uma
coleção do tipo <code class="language-text">set</code> é verificar pertinência eficientemente, então
essa é uma escolha de estrutura de dados ideal para nosso algoritmo.
Vamos criar uma implementação alternativa de nosso programa, dessa
vez usando conjuntos.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ler_palavras_frequentes</span>(nome_arquivo, n):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;lê o arquivo de frequência de palavras</span>
<span style="color: #BA2121; font-style: italic">    e devolve as n palavras mais frequentes&quot;&quot;&quot;</span>

    conjunto <span style="color: #666666">=</span> <span style="color: #008000">set</span>()
    <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(nome_arquivo) <span style="color: #008000; font-weight: bold">as</span> arquivo:
        i <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> linha <span style="color: #AA22FF; font-weight: bold">in</span> arquivo:
            palavra, _ <span style="color: #666666">=</span> linha<span style="color: #666666">.</span>strip()<span style="color: #666666">.</span>split()
            conjunto<span style="color: #666666">.</span>add(palavra)
            i <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">==</span> n:
                <span style="color: #008000; font-weight: bold">break</span>
    <span style="color: #008000; font-weight: bold">return</span> conjunto

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_diferenca</span>(a, b):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;recebe conjuntos a e b e devolve a - b&quot;&quot;&quot;</span>

    diferenca <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> elemento_a <span style="color: #AA22FF; font-weight: bold">in</span> a:
        <span style="color: #008000; font-weight: bold">if</span> elemento_a <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> b:
            diferenca<span style="color: #666666">.</span>append(elemento_a)
    <span style="color: #008000; font-weight: bold">return</span> diferenca

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">mostrar_conjunto</span>(conjunto):
    <span style="color: #008000; font-weight: bold">for</span> elemento <span style="color: #AA22FF; font-weight: bold">in</span> conjunto:
        <span style="color: #008000">print</span>(elemento)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    n <span style="color: #666666">=</span> <span style="color: #666666">100000</span>
    palavras_es <span style="color: #666666">=</span> ler_palavras_frequentes(<span style="color: #BA2121">&quot;es.txt&quot;</span>, n)
    palavras_pt_br <span style="color: #666666">=</span> ler_palavras_frequentes(<span style="color: #BA2121">&quot;pt_br.txt&quot;</span>, n)
    diferenca <span style="color: #666666">=</span> calcular_diferenca(palavras_es, palavras_pt_br)
    <span style="color: #408080; font-style: italic"># mostrar_conjunto(diferenca)</span>
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Queremos aprender {len(diferenca)} palavras.&quot;</span>)

main()
</pre><p>As funções para manipular conjuntos são ligeiramente diferentes das
funções de lista, mas não é difícil se acostumar. Executando,
devemos obter a mesma resposta -- o algoritmo é o mesmo, só mudamos
a escolha da estrutura de dados.</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> python3 diferenca_conjuntos.py
<span style="color: #888888">Queremos aprender 57529 palavras.</span>
</pre><p>A resposta é mostrada em pouco menos de 150ms, quase não dá pra
perceber. Essa é uma diferença espetacular! Dessa vez escolhemos uma
estrutura de dados mais adequada às operações de que nosso algoritmo
necessita. O motivo para essa diferença é que a representação dos
dados quando armazenamos um conjunto é cuidadosamente pensada para
executar a operação <code class="language-text">in</code> eficientemente. Nós não estudaremos essa
representação aqui, há toda uma disciplina dedicada a essas questões.</p>
<p>Uma pergunta deve inquietar quem sempre usou o tipo <code class="language-text">list</code> e aprendeu
que existe o tipo <code class="language-text">set</code>: se a operação <code class="language-text">in</code> em uma variável do tipo
conjunto é tão mais rápida, por que não usamos <code class="language-text">set</code> sempre? A
resposta é que, embora ambos tipos sirvam para armazenar conjuntos de
dados, eles são abstrações diferentes. Quando utilizamos uma lista, a
ordem em que os elementos são armazenados é importante. Quando
utilizamos um conjunto, abrimos mão dessa informação para construir
uma representação mais eficiente para o operador <code class="language-text">in</code>.</p>
<p>Uma última palavra: além da operação <code class="language-text">in</code>, o tipo <code class="language-text">set</code> permite
diversas outras operações sobre os conjuntos. Consulte a documentação
do Python e experimente utilizar várias delas. Em particular,
poderíamos fazer a diferença de conjuntos usando simplesmente o
operador <code class="language-text">-</code>. Por exemplo, faça o seguinte.</p>
<pre class="highlightlanguage-pycon"><span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>a <span style="color: #666666">=</span> {<span style="color: #666666">1</span>, <span style="color: #666666">3</span>, <span style="color: #666666">7</span>, <span style="color: #666666">2</span>}
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>b <span style="color: #666666">=</span> {<span style="color: #666666">7</span>, <span style="color: #666666">1</span>, <span style="color: #666666">8</span>}
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>a <span style="color: #666666">-</span> b
<span style="color: #888888">{2, 3}</span>
</pre><h2 id="dicionarios">Dicionários</h2>
<p>Agora vamos mudar um pouco e falar de números.</p>
<blockquote>
<p>Crie um programa que calcule o histograma de uma lista de números
inteiros.</p>
</blockquote>
<p>Primeiro precisamos relembrar o que é um histograma. Um <em>histograma</em>
sobre uma dada lista de elementos é uma tabela de contagem que associa
cada elemento distinto ao número de vezes que ele aparece na lista.
Quando estamos falando de superconjuntos (conjuntos que permitem a
repetição de elementos), o número de vezes também é chamado de
<em>multiplicidade</em>.</p>
<p>Esse problema parece muito simples. De fato, não é muito difícil
escrever um algoritmo para ele.</p>
<ol>
<li>
<p>Para cada número $n$ da entrada:</p>
<p>a) se $n$ não apareceu ainda:</p>
<ul>
<li>faça a multiplicidade de $n$ receber $1$</li>
<li>armazene a contagem de $n$</li>
</ul>
<p>b) se $n$ já apareceu:</p>
<ul>
<li>encontre a contagem de $n$</li>
<li>incremente a multiplicidade de $n$</li>
</ul>
</li>
</ol>
<p>Pare que esse algoritmo esteja bem definido de fato, antes precisamos
dizer como vamos armazenar os números e as multiplicidades. Vimos que
para escrever um bom algoritmo, é fundamental pensar com cuidado na
representação dos dados que utilizaremos. Queremos guardar os números,
então uma lista de números é sempre uma opção. Como não estamos
preocupados com a ordem em que os números são armazenados e no nosso
algoritmo precisamos determinar repetidamente se um dado número está
na nossa coleção , utilizar um conjunto parece uma escolha muito
melhor.</p>
<p>Acontece que também queremos guardar os dados relativos à
multiplicidades. Poderíamos pensar em uma lista ou em um conjunto de
multiplicidades, mas como descobriríamos a qual número se refere cada
multiplicidade? Além disso, já sabemos que dados relacionados devem
andar juntos. Então queremos criar alguma abstração que associe um
número à sua multiplicidade. Digamos que uma <strong>contagem</strong> é uma lista
com dois elementos.</p>
<pre class="highlightlanguage-python">contagem <span style="color: #666666">=</span> [número, multiplicidade]
</pre><p>A maneira com que utilizamos uma lista aqui não é muito usual, afinal
os dois elementos são do mesmo tipo, mas têm significados bem
diferentes. Como a contagem de um número muda no decorrer do algoritmo
(e não queremos recriar a contagem cada vez que reencontrarmos um
número), utilizar uma lista dessa maneira nesse caso traz mais
vantagens do que desvantagens.</p>
<p>Agora, voltamos a pergunta de como representar um histograma. Uma boa
tentativa seria um conjunto de contagens, já que nosso algoritmo
precisa acessar uma contagem rapidamente. Mas isso tem um
problema. Quando estamos percorrendo a lista de entrada e encontramos
um número, queremos atualizar a multiplicidade desse número, mas não
há como acessar o par <code class="language-text">[número, multiplicidade]</code> diretamente. Temos
que que percorrer cada par de contagem até encontrarmos a contagem
correspondente. Para entender isso, tente descobrir qual a saída
do trecho abaixo.</p>
<pre class="highlightlanguage-python">conjunto <span style="color: #666666">=</span> {[<span style="color: #666666">1</span>, <span style="color: #666666">100</span>], [<span style="color: #666666">7</span>, <span style="color: #666666">21</span>], [<span style="color: #666666">3</span>, <span style="color: #666666">45</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">200</span>]}
<span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">7</span> <span style="color: #AA22FF; font-weight: bold">in</span> histograma:
    <span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;O número 7 está no conjunto&#39;</span>)
<span style="color: #008000; font-weight: bold">else</span>:
    <span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;O número 7 não está no conjunto&#39;</span>)
</pre><p>Claro que o número não está no conjunto. A variável referenciada por
<code class="language-text">conjunto</code> é do tipo <code class="language-text">set</code> e contém elementos do tipo lista; não há
nenhum número nesse conjunto. Como não há nenhuma vantagem em usar
conjuntos nesse exemplo, vamos utilizar listas, já que estamos mais
familiarizados com elas. Assim, vamos representar um histograma como
uma <strong>lista de contagens</strong>.</p>
<p>Com isso, podemos implementar o algoritmo acima.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_histograma</span>(lista_numeros):
    histograma <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> numero <span style="color: #AA22FF; font-weight: bold">in</span> lista_numeros:
        <span style="color: #008000; font-weight: bold">for</span> par <span style="color: #AA22FF; font-weight: bold">in</span> histograma:
            <span style="color: #008000; font-weight: bold">if</span> par[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> numero:
                par[<span style="color: #666666">1</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
                <span style="color: #008000; font-weight: bold">break</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            par <span style="color: #666666">=</span> [numero, <span style="color: #666666">1</span>]
            histograma<span style="color: #666666">.</span>append(par)

    <span style="color: #008000; font-weight: bold">return</span> histograma

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">mostrar_histograma</span>(histograma):
    <span style="color: #008000; font-weight: bold">for</span> numero, multiplicidade <span style="color: #AA22FF; font-weight: bold">in</span> histograma:
        <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Multiplicidade de </span><span style="color: #BB6688; font-weight: bold">{numero}</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">{multiplicidade}</span><span style="color: #BA2121">&quot;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    lista_numeros <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">7</span>, <span style="color: #666666">3</span>, <span style="color: #666666">2</span>, <span style="color: #666666">2</span>, <span style="color: #666666">6</span>, <span style="color: #666666">2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">6</span>]
    histograma <span style="color: #666666">=</span> calcular_histograma(lista_numeros)
    mostrar_histograma(histograma)

main()
</pre><p>Testando o programa para essa entrada pequena, parece tudo certo. O
que acontece quando o conjunto de dados é grande é que é interessante.
Vamos testar com um conjunto de 100.000 números, distribuídos entre 0
e 9999. Dessa vez, vamos usar alguns números aleatórios. Para
descobrir como criar esse arquivo, faça o exercício correspondente ao
módulo <code class="language-text">random</code> <a href="../fixacao/07-ordenacao.html">aqui</a>.</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> ls -lh muitos.txt
<span style="color: #888888">-rw-rw-r-- 1 user user 478K jun 13 22:46 muitos.txt</span>
<span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> head muitos_numeros.txt
<span style="color: #888888">15962</span>
<span style="color: #888888">10902</span>
<span style="color: #888888">8314</span>
<span style="color: #888888">14623</span>
<span style="color: #888888">3304</span>
<span style="color: #888888">4029</span>
<span style="color: #888888">12455</span>
<span style="color: #888888">3304</span>
<span style="color: #888888">19918</span>
<span style="color: #888888">8353</span>
</pre><p>Adaptamos o programa para ler o arquivo.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ler_arquivo</span>(nome_arquivo):
    <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(nome_arquivo) <span style="color: #008000; font-weight: bold">as</span> arquivo:
        lista_numeros <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> linha <span style="color: #AA22FF; font-weight: bold">in</span> arquivo:
            numero <span style="color: #666666">=</span> <span style="color: #008000">int</span>(linha)
            lista_numeros<span style="color: #666666">.</span>append(numero)
        <span style="color: #008000; font-weight: bold">return</span> lista_numeros

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    lista_numeros <span style="color: #666666">=</span> ler_arquivo(<span style="color: #BA2121">&quot;muitos.txt&quot;</span>)
    histograma <span style="color: #666666">=</span> calcular_histograma(lista_numeros)
    mostrar_histograma(histograma)
</pre><p>Executamos e esperamos cerca de 15 segundos para o programa terminar.
Nada surpreendente. Já sabemos que a estrutura de dados utilizada para
representar os dados não é muito boa para as operações de que nosso
algoritmo precisa. Veremos que Python tem uma estrutura de dados
chamada <code class="language-text">dict</code>, ou tipo dicionário, que é especialmente adequada para
nosso algoritmo. Antes de introduzir dicionários, vamos resolver uma
versão bem mais simples do problema. A esperança é que esse exercício
mais simples nos dê uma intuição sobre qual seria a estrutura de dados
ideal.</p>
<blockquote>
<p>Crie um programa que calcule o histograma de uma lista de números
inteiros entre 0 e 9999.</p>
</blockquote>
<p>Esse é quase o mesmo problema, mas agora podemos supor que todos os
números da entrada estão nesse intervalo. Isso sugere que podemos
guardar as multiplicidades dos números em um vetor de 10000 posições:
os números da entrada correspondem a índices desse vetor. Isso é
conveniente pois podemos acessar o dado associado a cada número
diretamente!</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ler_arquivo</span>(nome_arquivo):
    <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(nome_arquivo) <span style="color: #008000; font-weight: bold">as</span> arquivo:
        lista_numeros <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> linha <span style="color: #AA22FF; font-weight: bold">in</span> arquivo:
            numero <span style="color: #666666">=</span> <span style="color: #008000">int</span>(linha)
            lista_numeros<span style="color: #666666">.</span>append(numero)
        <span style="color: #008000; font-weight: bold">return</span> lista_numeros

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_histograma_simplificado</span>(lista_numeros):
    histograma <span style="color: #666666">=</span> [<span style="color: #666666">0</span>] <span style="color: #666666">*</span> <span style="color: #666666">10000</span>

    <span style="color: #008000; font-weight: bold">for</span> numero <span style="color: #AA22FF; font-weight: bold">in</span> lista_numeros:
        histograma[numero] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> histograma

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">mostrar_histograma</span>(histograma):
    <span style="color: #008000; font-weight: bold">for</span> numero, multiplicidade <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(histograma):
        <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Multiplicidade de </span><span style="color: #BB6688; font-weight: bold">{numero}</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">{multiplicidade}</span><span style="color: #BA2121">&quot;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    lista_numeros <span style="color: #666666">=</span> ler_arquivo(<span style="color: #BA2121">&quot;muitos.txt&quot;</span>)
    histograma <span style="color: #666666">=</span> calcular_histograma_simplificado(lista_numeros)
    mostrar_histograma(histograma)

main()
</pre><p>Observe atentamente como utilizamos cada número como um índice do
vetor. Dessa vez, o programa gastou cerca de 70ms para calcular o
histograma de 100.000 números. Acessar um índice de uma lista é muito
rápido! Para que isso tenha dado certo, foram fundamentais algumas
propriedades do problema simplificado.</p>
<ol>
<li>
<p>os elementos de entrada que queremos armazenar são números;</p>
</li>
<li>
<p>esses números estão no intervalo de 0 a 9999.</p>
</li>
</ol>
<p>Esse tipo de representação não funciona para o problema geral porque
podemos querer calcular histogramas de conjuntos de dados não
numéricos. Por exemplo, se quisermos criar um arquivo das palavras
mais frequentes de um idioma, o que estamos fazendo na verdade é um
histograma de palavras. Mesmo que os dados sejam números inteiros,
pode ser que esses números sejam muito grandes. Não queremos criar um
vetor que ocupa vários gigabytes de memória apenas para computar um
histograma.</p>
<p>Agora já podemos descrever o que queremos de uma estrutura de dados
para representar um histograma:</p>
<ol>
<li>
<p>queremos armazenar um conjunto de pares <code class="language-text">(chave, valor)</code> de forma
que cada chave só apareça uma vez no conjunto;</p>
</li>
<li>
<p>queremos decidir se uma determinada chave está na coleção,
independentemente do valor associado;</p>
</li>
<li>
<p>queremos modificar o valor associado a uma chave rapidamente, assim
como modificamos o valor associado a um índice de uma lista.</p>
</li>
</ol>
<p>Uma estrutura de dados que satisfaz todos esses requisitos é um <code class="language-text">dict</code>.
Vejamos alguns exemplos.</p>
<pre class="highlightlanguage-pycon"><span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>idades <span style="color: #666666">=</span> <span style="color: #008000">dict</span>()
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>idades[<span style="color: #BA2121">&quot;Ana&quot;</span>] <span style="color: #666666">=</span> <span style="color: #666666">18</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>idades[<span style="color: #BA2121">&quot;João&quot;</span>] <span style="color: #666666">=</span> <span style="color: #666666">17</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>idades[<span style="color: #BA2121">&quot;Mariana&quot;</span>] <span style="color: #666666">=</span> <span style="color: #666666">18</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>idades[<span style="color: #BA2121">&quot;Mariana&quot;</span>] <span style="color: #666666">=</span> <span style="color: #666666">19</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>idades
<span style="color: #888888">{&#39;Ana&#39;: 18, &#39;João&#39;: 17, &#39;Mariana&#39;: 19}</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>tipos_triangulos <span style="color: #666666">=</span> {
<span style="color: #000080; font-weight: bold">... </span>  (<span style="color: #666666">3</span>, <span style="color: #666666">3</span>, <span style="color: #666666">3</span>): <span style="color: #BA2121">&quot;equilátero&quot;</span>,
<span style="color: #000080; font-weight: bold">... </span>  (<span style="color: #666666">2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>): <span style="color: #BA2121">&quot;isósceles&quot;</span>,
<span style="color: #000080; font-weight: bold">... </span>  (<span style="color: #666666">2</span>, <span style="color: #666666">2</span>, <span style="color: #666666">1</span>): <span style="color: #BA2121">&quot;isósceles&quot;</span>,
<span style="color: #000080; font-weight: bold">... </span>  (<span style="color: #666666">3</span>, <span style="color: #666666">4</span>, <span style="color: #666666">5</span>): <span style="color: #BA2121">&quot;escaleno&quot;</span>,
<span style="color: #000080; font-weight: bold">... </span>}
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>tipos_triangulos
<span style="color: #888888">{(3, 3, 3): &#39;equilátero&#39;, (2, 1, 2): &#39;isósceles&#39;, (2, 2, 1): &#39;isósceles&#39;, (3, 4, 5): &#39;escaleno&#39;}</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>(<span style="color: #666666">5</span>,<span style="color: #666666">5</span>,<span style="color: #666666">5</span>) <span style="color: #AA22FF; font-weight: bold">in</span> tipos_triangulos
<span style="color: #888888">False</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>(<span style="color: #666666">5</span>,<span style="color: #666666">4</span>,<span style="color: #666666">3</span>) <span style="color: #AA22FF; font-weight: bold">in</span> tipos_triangulos
<span style="color: #888888">False</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>tipos_triangulos[(<span style="color: #666666">5</span>,<span style="color: #666666">5</span>,<span style="color: #666666">5</span>)] <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;equilátero&quot;</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>(<span style="color: #666666">5</span>,<span style="color: #666666">5</span>,<span style="color: #666666">5</span>) <span style="color: #AA22FF; font-weight: bold">in</span> tipos_triangulos
<span style="color: #888888">True</span>
</pre><p>Veja o trecho acima com cuidado e, se tiver dúvidas sobre a sintaxe,
consulte o tutorial Python. Na primeira linha, a atribuição
<code class="language-text">idades = dict()</code> cria um dicionário vazio e associa ao nome idades.
Poderíamos escrever apenas <code class="language-text">idades = {}</code>, mas preferi escrever
<code class="language-text">dict()</code> para explicitar que estamos criando um dicionário. Com isso,
já podemos ajustar nossa função para calcular histogramas.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_histograma</span>(lista):
    histograma <span style="color: #666666">=</span> {}

    <span style="color: #008000; font-weight: bold">for</span> elemento <span style="color: #AA22FF; font-weight: bold">in</span> lista:
        <span style="color: #008000; font-weight: bold">if</span> elemento <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> histograma:
            histograma[elemento] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            histograma[elemento] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> histograma

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">mostrar_histograma</span>(histograma):
    <span style="color: #008000; font-weight: bold">for</span> elemento, multiplicidade <span style="color: #AA22FF; font-weight: bold">in</span> histograma<span style="color: #666666">.</span>items():
        <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Multiplicidade de </span><span style="color: #BB6688; font-weight: bold">{elemento}</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">{multiplicidade}</span><span style="color: #BA2121">&quot;</span>)
</pre><p>Repare que para percorrer os pares <code class="language-text">(chave, valor)</code> de um dicionário,
chamamos a função <code class="language-text">items</code>. Se não tivéssemos usado essa função,
iríamos iterar apenas sobre as chaves. Executamos a versão atualizada
do programa com o arquivo de 100.000 inteiros. Ela gasta cerca de 70ms
apenas e ainda funciona com entradas arbitrárias.</p>
<h1 id="registros-e-mutabilidade">Registros e mutabilidade</h1>
<p>Agora que já conhecemos o tipo dicionário, podemos repensar a
representação de um verbete do nosso primeiro exemplo. Lá, dissemos
que um verbete era uma tupla da forma <code class="language-text">(palavra, definição, ano)</code>. Há
algumas desvantagens em se utilizar uma tupla dessa maneira. A
principal delas é que para acessar uma dado associado ao verbete
precisamos utilizar um índice numérico que não tem nada a ver com o
significado daquele dado.</p>
<p>Por exemplo, na nossa representação, a definição de uma palavra é
<code class="language-text">verbete[1]</code>, mas se tivéssemos abstraído um verbete como uma tupla da
forma <code class="language-text">(palavra, ano, definição)</code>, deveríamos escrever <code class="language-text">verbete[2]</code>.
Pior, se algum dia quisermos adicionar outro dado associado a um
verbete, então teremos que revisitar todos os trechos de código que
lidam com a representação de um verbete! Digamos que depois de um
tempo decidamos armazenar juntamente com um verbete a classe associada
a determinada palavra (substantivo, adjetivo, etc.). Atualizamos a
representação de um verbete para uma tupla da forma
<code class="language-text">(palavra, classe, definição, ano)</code>.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">atualizar_definicao</span>(dicionario, palavra, nova_definicao):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;atualiza a definição de uma palavra&quot;&quot;&quot;</span>

    i <span style="color: #666666">=</span> procurar_indice(dicionario, palavra)
    verbete_antigo <span style="color: #666666">=</span> dicionario[i]
    verbete_novo <span style="color: #666666">=</span> (verbete_antigo[<span style="color: #666666">0</span>], verbete_antigo[<span style="color: #666666">1</span>], nova_definicao, verbete_antigo[<span style="color: #666666">3</span>])
    dicionario[i] <span style="color: #666666">=</span> verbete_novo

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    dicionario <span style="color: #666666">=</span> criar_dicionario()

    verbete <span style="color: #666666">=</span> (<span style="color: #BA2121">&quot;amor&quot;</span>, <span style="color: #BA2121">&quot;substantivo&quot;</span>, <span style="color: #BA2121">&quot;fogo que arde sem se ver&quot;</span>, <span style="color: #666666">1595</span>)
    adicionar_verbete(dicionario, verbete)

    verbete <span style="color: #666666">=</span> procurar_verbete(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>)
    palavra, classe, definicao, ano <span style="color: #666666">=</span> verbete
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;</span><span style="color: #BB6688; font-weight: bold">{palavra}</span><span style="color: #BA2121"> significa </span><span style="color: #BB6688; font-weight: bold">{definicao}</span><span style="color: #BA2121">&quot;</span>)

    nova_definicao <span style="color: #666666">=</span> <span style="color: #008000">input</span>(<span style="color: #BA2121">&quot;O que você acha que é o amor?</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)
    atualizar_definicao(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>, nova_definicao)

    palavra, definicao, ano <span style="color: #666666">=</span> procurar_verbete(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;</span><span style="color: #BB6688; font-weight: bold">{palavra}</span><span style="color: #BA2121"> agora significa </span><span style="color: #BB6688; font-weight: bold">{definicao}</span><span style="color: #BA2121">&quot;</span>)
</pre><p>Tivemos que alterar praticamente toda a função <code class="language-text">main</code>, já que ela cria
e manipula os verbetes. O que foi desagradável é que tivemos que
alterar também a função <code class="language-text">atualizar_definicao</code>, mesmo que a definição
não tenha nada a ver com a classe da palavra. Sempre que mudamos a
representação em memória de uma certa abstração precisamos revisar
todas as instruções que acessam essa representação diretamente.
Aff... esqueci de atualizar as variáveis recebidas na última chamada
a <code class="language-text">procurar_verbete</code>.</p>
<p>Em uma boa abstração, gostaríamos de acessar a definição associada ao
verbete sem nos preocupar com a forma com que ele é representado. Uma
estratégia bastante comum em Python é criar um dicionário que
representa um registro de uma coleção de dados. Assim, ao invés de
utilizar uma tupla, representamos um verbete por um dicionário como no
exemplo</p>
<pre class="highlightlanguage-python">verbete <span style="color: #666666">=</span> {
  <span style="color: #BA2121">&quot;palavra&quot;</span>: <span style="color: #BA2121">&quot;amor&quot;</span>,
  <span style="color: #BA2121">&quot;classe&quot;</span>: <span style="color: #BA2121">&quot;substantivo&quot;</span>,
  <span style="color: #BA2121">&quot;definicao&quot;</span>: <span style="color: #BA2121">&quot;ferida que dói e não se sente&quot;</span>,
  <span style="color: #BA2121">&quot;ano&quot;</span>: <span style="color: #666666">1595</span>,
}
</pre><p>Vamos adaptar, mais uma vez, o nosso programa.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">criar_dicionario</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;cria um dicionário vazio&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">return</span> []

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">adicionar_verbete</span>(dicionario, verbete):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;adiciona um novo verbete ao dicionário&quot;&quot;&quot;</span>

    i <span style="color: #666666">=</span> procurar_indice(dicionario, verbete[<span style="color: #BA2121">&quot;palavra&quot;</span>])
    <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
        dicionario<span style="color: #666666">.</span>append(verbete)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">Exception</span>(<span style="color: #BA2121">f&quot;Palavra </span><span style="color: #BB6688; font-weight: bold">{verbete[&#39;palavra&#39;]}</span><span style="color: #BA2121"> já existe.&quot;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">procurar_verbete</span>(dicionario, palavra):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;devolve o verbete correspondente à palavra;</span>
<span style="color: #BA2121; font-style: italic">    se palavra não for encontrada, devolve None&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">for</span> verbete <span style="color: #AA22FF; font-weight: bold">in</span> dicionario:
        <span style="color: #008000; font-weight: bold">if</span> verbete[<span style="color: #BA2121">&quot;palavra&quot;</span>] <span style="color: #666666">==</span> palavra:
            <span style="color: #008000; font-weight: bold">return</span> verbete
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">procurar_indice</span>(dicionario, palavra):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;devolve o índice correspondente à palavra</span>
<span style="color: #BA2121; font-style: italic">    ou None se ela não existir no dicionário&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">for</span> i, verbete <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dicionario):
        <span style="color: #008000; font-weight: bold">if</span> verbete[<span style="color: #BA2121">&quot;palavra&quot;</span>] <span style="color: #666666">==</span> palavra:
            <span style="color: #008000; font-weight: bold">return</span> i
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">atualizar_definicao</span>(dicionario, palavra, nova_definicao):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;atualiza a definição de uma palavra&quot;&quot;&quot;</span>

    i <span style="color: #666666">=</span> procurar_indice(dicionario, palavra)
    verbete <span style="color: #666666">=</span> dicionario[i]
    verbete[<span style="color: #BA2121">&quot;definicao&quot;</span>] <span style="color: #666666">=</span> nova_definicao

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    dicionario <span style="color: #666666">=</span> criar_dicionario()

    verbete <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;palavra&quot;</span>: <span style="color: #BA2121">&quot;amor&quot;</span>,
        <span style="color: #BA2121">&quot;classe&quot;</span>: <span style="color: #BA2121">&quot;substantivo&quot;</span>,
        <span style="color: #BA2121">&quot;definicao&quot;</span>: <span style="color: #BA2121">&quot;fogo que arde sem se ver&quot;</span>,
        <span style="color: #BA2121">&quot;ano&quot;</span>: <span style="color: #666666">1595</span>,
    }
    adicionar_verbete(dicionario, verbete)

    verbete <span style="color: #666666">=</span> procurar_verbete(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;</span><span style="color: #BB6688; font-weight: bold">{verbete[&#39;palavra&#39;]}</span><span style="color: #BA2121"> significa </span><span style="color: #BB6688; font-weight: bold">{verbete[&#39;definicao&#39;]}</span><span style="color: #BA2121">&quot;</span>)

    nova_definicao <span style="color: #666666">=</span> <span style="color: #008000">input</span>(<span style="color: #BA2121">&quot;O que você acha que é o amor?</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>)
    atualizar_definicao(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>, nova_definicao)

    verbete <span style="color: #666666">=</span> procurar_verbete(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;</span><span style="color: #BB6688; font-weight: bold">{verbete[&#39;palavra&#39;]}</span><span style="color: #BA2121"> agora significa </span><span style="color: #BB6688; font-weight: bold">{verbete[&#39;definicao&#39;]}</span><span style="color: #BA2121">&quot;</span>)


main()
</pre><p>Você deve comparar essa implementação com a anterior e decidir qual é
mais fácil de ler e entender. Se compararmos com atenção, no entanto,
vamos ver que a maneira que implementamos <code class="language-text">alterar_definicao</code> na
versão com dicionários é ligeiramente diferente da maneira que
implementamos essa mesma função na versão com lista. Antes, como não
podíamos alterar os dados de uma tupla, criamos um novo verbete e
<em>substituímos</em> o verbete antigo pelo novo. Agora, apenas alteramos o
verbete diretamente.</p>
<p>Vamos investigar as consequências disso. Primeiro vamos executar o
seguinte trecho de código, utilizando a representação de nossa coleção
de verbetes como uma lista de tuplas.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    dicionario <span style="color: #666666">=</span> criar_dicionario()

    anterior <span style="color: #666666">=</span> (<span style="color: #BA2121">&quot;amor&quot;</span>, <span style="color: #BA2121">&quot;substantivo&quot;</span>, <span style="color: #BA2121">&quot;fogo que arde sem se ver&quot;</span>, <span style="color: #666666">1595</span>)
    adicionar_verbete(dicionario, anterior)
    atualizar_definicao(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>, <span style="color: #BA2121">&quot;um contentamento descontente&quot;</span>)
    atual <span style="color: #666666">=</span> procurar_verbete(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>)

    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;antes, amor era </span><span style="color: #BB6688; font-weight: bold">{anterior[2]}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;agora, amor é </span><span style="color: #BB6688; font-weight: bold">{atual[2]}</span><span style="color: #BA2121">&quot;</span>)
</pre><pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> python3 dicionario_tuplas.py
<span style="color: #888888">antes, amor era fogo que arde sem se ver</span>
<span style="color: #888888">agora, amor é um contentamento descontente</span>
</pre><p>Tudo dentro do esperado. Vamos utilizar a implementação com
dicionário.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    dicionario <span style="color: #666666">=</span> criar_dicionario()

    anterior <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;palavra&quot;</span>: <span style="color: #BA2121">&quot;amor&quot;</span>,
        <span style="color: #BA2121">&quot;classe&quot;</span>: <span style="color: #BA2121">&quot;substantivo&quot;</span>,
        <span style="color: #BA2121">&quot;definicao&quot;</span>: <span style="color: #BA2121">&quot;fogo que arde sem se ver&quot;</span>,
        <span style="color: #BA2121">&quot;ano&quot;</span>: <span style="color: #666666">1595</span>,
    }
    adicionar_verbete(dicionario, anterior)
    atualizar_definicao(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>, <span style="color: #BA2121">&quot;um contentamento descontente&quot;</span>)
    atual <span style="color: #666666">=</span> procurar_verbete(dicionario, <span style="color: #BA2121">&quot;amor&quot;</span>)

    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;antes, amor era </span><span style="color: #BB6688; font-weight: bold">{anterior[&#39;definicao&#39;]}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;agora, amor é </span><span style="color: #BB6688; font-weight: bold">{atual[&#39;definicao&#39;]}</span><span style="color: #BA2121">&quot;</span>)
</pre><pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/colecoes$</span> python3 dicionario_dict.py
<span style="color: #888888">antes, amor era um contentamento descontente</span>
<span style="color: #888888">agora, amor é um contentamento descontente</span>
</pre><p>A definição do verbete <code class="language-text">anterior</code> é a mesma do verbete <code class="language-text">atual</code>! Isso
acontece porque o verbete alterado <code class="language-text">atualizar_definicao</code> é o mesmo
verbete adicionado anteriormente. Em outras palavras, <code class="language-text">anterior</code> e
<code class="language-text">atual</code> são o mesmo objeto.</p>
<p>Vamos fazer um desenho da memória das variáveis desses programas no
momento em que a função <code class="language-text">atualizar_definicao</code> termina. Lembre-se de
que, nos nossos desenhos, costumamos representar os valores das
variáveis por retângulos, então cada retângulo corresponde a um objeto
distinto. Para a implementação que usa lista de tuplas, temos o
seguinte desenho.</p>
<img src="figs/atualizar_tupla.png" style="width: 100%; max-width: 500px;">
<p>E para a implementação que usa lista de dicionário, o seguinte.</p>
<img src="figs/atualizar_dicionario.png" style="width: 100%; max-width: 500px;">
<p>Para entender a diferença, precisamos aprender o conceito de
<strong>identidade</strong>. Já falamos que toda variável em Python é um objeto na
memória com determinado tipo e, normalmente, referenciado pelo nome de
uma variável. A identidade de um objeto é um número inteiro associado
a esse objeto e a nenhum outro. Podemos pensar que cada objeto é um
pequeno espaço reservado na memória. Assim, se dois objetos tiverem a
mesma identidade, eles são os mesmos objetos.</p>
<p>Para verificar se dois objetos são o mesmo, utilizamos o operador
<code class="language-text">is</code>. Para descobrir a identidade de um objeto, utilizamos a função
<code class="language-text">id</code>. Experimente adicionar o trecho abaixo às funções acima e
executar com cada implementação. Depois faça alterações no código e
experimente até internalizar esses conceitos. Por exemplo, chame a
função <code class="language-text">atualizar_definicao</code> passando como parâmetro a definição
original.</p>
<pre class="highlightlanguage-python">    <span style="color: #008000; font-weight: bold">if</span> atual <span style="color: #666666">==</span> anterior:
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;objetos são iguais&quot;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;objetos são diferentes&quot;</span>)

    <span style="color: #008000; font-weight: bold">if</span> atual <span style="color: #AA22FF; font-weight: bold">is</span> anterior:
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;atual e anterior são o mesmo objeto&quot;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;atual e anterior são objetos distintos&quot;</span>)

    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;o identificador de anterior é {id(anterior)}&quot;</span>)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;o identificador de atual é {id(atual)}&quot;</span>)
</pre><p>Esses exemplos ilustram bem um conceito fundamental em Python e de
linguagens de programação em geral: <strong>mutabilidade</strong>. Um tipo de
variável é imutável se um objeto desse tipo não muda nunca.</p>
<p>São exemplos de tipos imutáveis: <code class="language-text">int</code>, <code class="language-text">str</code>, <code class="language-text">tuple</code>. Você pode
desconfiar dessa afirmação, afinal de conta, inúmeras vezes já
escrevemos programas que modificam variáveis inteiras. Por exemplo,
para calcular o dobro de um número podemos escrever.</p>
<pre class="highlightlanguage-python">n <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">input</span>())
n <span style="color: #666666">=</span> <span style="color: #666666">2</span> <span style="color: #666666">*</span> n
<span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;O dobro é </span><span style="color: #BB6688; font-weight: bold">{n}</span><span style="color: #BA2121">&quot;</span>)
</pre><p>Lembremos: quando fazemos uma atribuição, primeiro calculamos o valor
da expressão do lado direito do <code class="language-text">=</code> e depois associamos o nome a
esquerda a esse valor. Portanto, quando escrevemos <code class="language-text">n = 2 * n</code>
(leia-se, <code class="language-text">n</code> recebe <code class="language-text">2 * n</code>), o que estamos fazendo é substituir o
valor referenciado pelo seu dobro. Isso pode ser ilustrado pela figura
abaixo.</p>
<img src="figs/atribuicao.png" style="width: 100%; max-width: 500px;">
<p>São exemplos de tipos mutáveis <code class="language-text">list</code> e <code class="language-text">dict</code>. Devemos tomar cuidado:
quando dizemos que uma lista é mutável, estamos falando que estamos
alterando o objeto correspondente à lista. Se fizermos uma atribuição,
então, estaremos alterando a referência do nome, não o objeto.
Considere o exemplo que mostra duas maneiras distintas de ordenar uma
lista em Python.</p>
<pre class="highlightlanguage-python">lista_strings <span style="color: #666666">=</span> [<span style="color: #BA2121">&quot;ana&quot;</span>, <span style="color: #BA2121">&quot;maria&quot;</span>, <span style="color: #BA2121">&quot;beto&quot;</span>]
apelido_lista_strings <span style="color: #666666">=</span> lista_strings
lista_inteiros <span style="color: #666666">=</span> [<span style="color: #666666">3</span>, <span style="color: #666666">4</span>, <span style="color: #666666">2</span>, <span style="color: #666666">1</span>]
apelido_lista_inteiros <span style="color: #666666">=</span> lista_strings
lista_strings<span style="color: #666666">.</span>sort()
lista_inteiros <span style="color: #666666">=</span> <span style="color: #008000">sorted</span>(lista_inteiros)
<span style="color: #008000">print</span>(apelido_lista_strings)
<span style="color: #008000">print</span>(apelido_lista_inteiros)
</pre><p>Descubra qual é a saída deste trecho. Para isso, faça um desenho que
representa a memória do processo. Depois, confira sua resposta
simulando esse código no terminal interativo do Python.</p>
<h3 id="um-parentese-json">Um parêntese: JSON</h3>
<p>Normalmente, não guardamos os dados diretamente no código de um
programa. Para armazená-los permanentemente podemos utilizar
diferentes mecanismos, como banco de dados, arquivos binários ou
arquivos texto. A escolha depende da aplicação. Em diversas situações,
quando a quantidade de dados não é tão grande e queremos apenas
consultar os dados, podemos usar um arquivo JSON. Um arquivo JSON é um
formato estruturado de guardar conjuntos de dados bastante popular na
internet. A grande vantagem desse formato (e de outros similares, como
XML, Yaml, Toml etc.) é que ele se mapeia muito facilmente com as
representações de coleções de dados que normalmente utilizamos em
nossos programa. Depois, não deixe de fazer o exercício de fixação
correspondente.</p>
<h2 id="classes">Classes</h2>
<p><strong>Um aviso</strong>: Você não precisa criar ou usar classes nesta disciplina,
mas eventualmente precisará lidar com elas quando estiver trabalhando
com Python. Aqui, iremos utilizar classes apenas como meio para
guardar um conjunto de dados associados, assim como fizemos com tuplas
e dicionários. Há diversas outros motivos pelos quais se usa uma
classe, mas não vamos colocar o carro na frente dos bois.</p>
<p>Suponha que o dicionarista decida adicionar mais uma palavra ao
dicionário.</p>
<pre class="highlightlanguage-python">    verbete <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;palavra&quot;</span>: <span style="color: #BA2121">&quot;liberdade&quot;</span>,
        <span style="color: #BA2121">&quot;definicao&quot;</span>: <span style="color: #BA2121">&quot;palava que o sonho humano alimenta&quot;</span>,
        <span style="color: #BA2121">&quot;ano&quot;</span>: <span style="color: #666666">1953</span>,
    }
    adicionar_verbete(dicionario, anterior)
</pre><p>Este trecho é inofensivo e quando executado não irá causar nenhum
erro, mas ele tem um problema de consistência. Um verbete deveria ter
todos as chaves <code class="language-text">&quot;palavra&quot;</code>, <code class="language-text">&quot;classe&quot;</code>, <code class="language-text">&quot;definicao&quot;</code> e <code class="language-text">&quot;ano&quot;</code>, mas
esquecemos de <code class="language-text">&quot;classe&quot;</code>. Esse é um tipo de erro muito comum que
aconteceu porque, quando criamos o verbete, precisamos nos preocupar
com os detalhes de como ele é representado na memória. Para evitar
esse tipo de problema, podemos criar uma função cujo único objetivo é
criar um verbete. Assim, se esquecermos de algum dado, identificaremos
o erro, antes mesmo de executarmos o programa.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">criar_verbete</span>(palavra, classe, definicao, ano):
    verbete <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&quot;palavra&quot;</span>: palavra,
        <span style="color: #BA2121">&quot;classe&quot;</span>: classe,
        <span style="color: #BA2121">&quot;definicao&quot;</span>: definicao,
        <span style="color: #BA2121">&quot;ano&quot;</span>: ano,
    }
    <span style="color: #008000; font-weight: bold">return</span> verbete
</pre><p>Quando representamos um verbete usando um dicionário, estamos fazendo
uma abstração nova, mas não estamos criando um novo tipo de variável.
O problema de usar um dicionário diretamente é que, se não formos
cuidados, podemos acaber realizando operações sobre o objeto de forma
a deixar a representação inconsistente. Para abstrações simples como
essa, um dicionário é suficiente. Mas, para abstrações mais
complicadas precisamos criar um novo tipo de variável. Em Python,
fazemos isso usando usamos classes.</p>
<p>Em seguida, criamos uma classe que representa um verbete e uma função
<code class="language-text">main</code> que cria um objeto desse novo tipo.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Verbete</span>:
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, palavra, classe, definicao, ano):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>palavra <span style="color: #666666">=</span> palavra
        <span style="color: #008000">self</span><span style="color: #666666">.</span>classe <span style="color: #666666">=</span> classe
        <span style="color: #008000">self</span><span style="color: #666666">.</span>definicao <span style="color: #666666">=</span> definicao
        <span style="color: #008000">self</span><span style="color: #666666">.</span>ano <span style="color: #666666">=</span> ano

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    verbete <span style="color: #666666">=</span> Verbete(<span style="color: #BA2121">&quot;amor&quot;</span>, <span style="color: #BA2121">&quot;substantivo&quot;</span>, <span style="color: #BA2121">&quot;estar-se preso por vontade&quot;</span>, <span style="color: #666666">1595</span>)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;amor significa </span><span style="color: #BB6688; font-weight: bold">{verbete.definicao}</span><span style="color: #BA2121">&quot;</span>)
    <span style="color: #008000">print</span>(<span style="color: #008000">type</span>(objeto))
</pre><p>Há vários detalhes aqui que precisamos entender. Primeiro, observe que
chamamos o nome da classe como se ela fosse uma função. Quando essa
instrução é executada, o que acontece é o seguinte:</p>
<ol>
<li>O interpretador Python cria um novo objeto na memória do tipo
<code class="language-text">Verbete</code>.</li>
<li>A função <code class="language-text">Verbete.__init__</code> é chamada para inicializar esse objeto.
O primeiro parâmetro deve ser <code class="language-text">self</code> e corresponde ao objeto recém
criado. Os demais parâmetros são os parâmetros passados na chamada
<code class="language-text">Verbete(...)</code>.</li>
<li>A função é executada e cria os diversos atributos contendo os dados
associados ao verbete.</li>
</ol>
<p>Além dos atributos, uma classe pode definir funções que operam sobre o
objeto. Por exemplo, digamos que classificamos uma palavra como
neologismo se ela for catalogada a partir de certo ano.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Verbete</span>:
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, palavra, classe, definicao, ano):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>palavra <span style="color: #666666">=</span> palavra
        <span style="color: #008000">self</span><span style="color: #666666">.</span>classe <span style="color: #666666">=</span> classe
        <span style="color: #008000">self</span><span style="color: #666666">.</span>definicao <span style="color: #666666">=</span> definicao
        <span style="color: #008000">self</span><span style="color: #666666">.</span>ano <span style="color: #666666">=</span> ano

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eh_neologismo</span>(<span style="color: #008000">self</span>):
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>ano <span style="color: #666666">&gt;=</span> <span style="color: #666666">1990</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">True</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">False</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    verbete <span style="color: #666666">=</span> Verbete(<span style="color: #BA2121">&quot;smartphone&quot;</span>, <span style="color: #BA2121">&quot;substantivo&quot;</span>, <span style="color: #BA2121">&quot;um telefone, só que mais caro&quot;</span>, <span style="color: #666666">1997</span>)
    <span style="color: #008000; font-weight: bold">if</span> verbete<span style="color: #666666">.</span>eh_neologismo():
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;a palavra é um neologismo&quot;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;a palavra não é um neologismo&quot;</span>)
</pre><p>Enquanto o termo classe possa ser uma novidade, já estamos lidando com
elas há muito tempo. Todos os valores em Python são objetos de alguma
classe! Por exemplos, listas são objetos da classe <code class="language-text">list</code>.</p>
<pre class="highlight">lista1 = []
lista2 = list()
</pre><p>O trecho acima cria dois objetos do tipo <code class="language-text">list</code>. A expressão <code class="language-text">[]</code> nada
mais é do que um atalho para uma chamada <code class="language-text">list()</code>. Quando usamos o
nome de um tipo como se fosse uma função, reservamos um espaço na
memória para um novo objeto. Esse espaço é preenchido por uma função
especial de inicialização; nesse caso, <code class="language-text">list.__init__</code>.</p>
<p>Agora, modifique nosso programa para que a coleção de verbetes seja
representada como uma lista de objetos do tipo <code class="language-text">Verbete</code>. Isso não
deve ser difícil, basta mudar expressões como <code class="language-text">verbete[&quot;palavra&quot;]</code>
para expressões como <code class="language-text">verbete.palavra</code>.</p>
<h3 id="alternativas">Alternativas</h3>
<p>Adicionar um tipo novo parece trivial, mas se feito sem cuidado pode
complicar o nosso programa e prejudicar o entendimento ou a execução
de nosso algoritmo. Se tudo o que queremos é acessar os dados de uma
tupla através de um nome, então poderíamos usar uma
<a href="https://docs.python.org/pt-br/3/library/collections.html#collections.namedtuple"><code class="language-text">namedtuple</code></a>,
ou se precisarmos de um objeto mutável, um
<a href="https://docs.python.org/pt-br/3/library/types.html#types.SimpleNamespace"><code class="language-text">SimpleNamespace</code></a>.
Não vamos estudar todos os tipos da linguagem, nem é necessário para a
disciplina. Mas é sempre bom saber que eles existem.</p>
<p>Finalmente, nossa abstração do dicionário de palavras representado
como uma lista sofre dos mesmos problemas que nossa primeira versão da
função para calcular um histograma. A solução deve ser clara agora:
utilizar uma estrutura de dados mais adequada. Dessa vez, vou deixar
para você fazer — ainda mais uma — implementação do dicionário.</p>


        <!-- Navigation buttons -->
<div role="navigation" class="row justify-content-between">

  <div class="col-12 col-sm-5 col-lg-4">
    <a class="btn btn-primary w-100 mt-1 mt-sm-0" href="08-matrizes.html">
      &larr; Anterior
    </a>
  </div>

  <div class="col-12 d-none d-lg-inline-block col-lg-4">
    <a class="btn btn-secondary w-100" href="../index.html">
      Voltar
    </a>
  </div>

  <div class="col-12 col-sm-5 col-lg-4">
    <a class="btn btn-primary w-100 mt-1 mt-sm-0" href="10-eficiencia.html">
      Próxima &rarr;
    </a>
  </div>

</div>      </div>
    </div>
</article>

<hr />


<!-- Footer -->
<footer>
  <p class="copyright text-muted">
    <a href="https://www.ic.unicamp.br/~lehilton/" title="Página pessoal">
      Copyright &copy; 2020
    </a>
  </p>
</footer>
<!-- Bootstrap core JavaScript -->
<script src="../dist/vendor/jquery/jquery.min.js"></script>
<script src="../dist/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<!-- <script src="../dist/vendor/prism/prism.js"></script> -->

<!-- Custom scripts for this template -->
<script src="../dist/js/main.min.js"></script>

<!-- Mathjax setup -->
<script>
  MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
  };
</script>
<script src="../dist/vendor/mathjax/tex-chtml.js" id="MathJax-script" async></script>



  </body>

</html>