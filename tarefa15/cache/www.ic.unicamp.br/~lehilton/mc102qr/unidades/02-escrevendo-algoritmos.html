<!DOCTYPE html>

<html lang="pt-br">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    Algoritmos e Programação de Computadores
    - Escrevendo algoritmos
  </title>

  <meta name="keywords" content="MC102, Algoritmos e Programação de Computadores, Python">
  <meta name="description" content="Página da disciplina de MC102 para turma QR">
  <meta name="author" content="Lehilton Pedrosa">

  <!-- Bootstrap core CSS -->
  <link href="../dist/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Theme css -->
  <link href="../dist/css/main.min.css" rel="stylesheet">

  <!-- Prism -->
  <!-- <link href="../dist/vendor/prism/prism.css" rel="stylesheet" /> -->
</head>
<body >

  <body>

<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="../index.html">MC102</a>


    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i>&#9776;</i>
    </button>

    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">

        <li class="nav-item top back-to-top-link">
          <a class="nav-link" href="#"><span class="glyphicon glyphicon-align-left" aria-hidden="true"></span>topo</a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="../index.html">voltar</a>
        </li>


      </ul>
    </div>
  </div>
</nav>

<!-- Page Header -->
<header class="masthead"   style="background-image: url('../images/home-bg.jpg')" >
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <div class="post-heading">

          <h1 >Escrevendo algoritmos</h1>


          <span class="meta">Quinta, 12 de março de 2020</span>

        </div>
      </div>
    </div>
  </div>
</header>
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">


      <div class="col-lg-8 col-md-10 mx-auto">

        <h1 id="escrevendo-um-algoritmo">Escrevendo um algoritmo</h1>
<p>Nós já sabemos o que é um algoritmo. Ele é um texto com diversas
instruções. Normalmente, podemos imaginar que um algoritmo será
executado por um certo robozinho. Esse robô é o <strong>processador</strong> que
irá executar as instruções do algoritmo, então é fundamental que só
demos a ele ordens bem básicas, que ele seja capaz de cumprir.</p>
<p>Assim, queremos escrever um algoritmo que só contenha <em>instruções
elementares</em>. Mais do que isso, também é importante projetar um
mecanismo que diga ao robô qual instrução ele deverá executar em
seguida e quando o algoritmo termina. Por isso, nosso algoritmo terá
algumas <em>instruções de controle</em> que digam a ordem e a forma em que as
ações são executadas.</p>
<h2 id="estruturas-de-controle">Estruturas de controle</h2>
<p>Vamos listar as estruturas de controle mais comumente utilizadas ao
escrever um algoritmo:</p>
<ul>
<li>
<p>O <strong>sequenciamento direto</strong> é a convenção do nosso algoritmo que
determina que uma instrução escrita antes no texto deve ser
executada antes. Normalmente é determinada implicitamente. Por
exemplo, se escrevermos uma instrução por linha, então sabemos que
cada linha é executada em ordem; se separarmos instruções por
ponto-e-vírgula, então podemos imaginar que esse ponto-e-vírgula
significa &quot;e depois faça&quot;, etc.</p>
</li>
<li>
<p>O <strong>desvio condicional</strong> é uma estrutura de controle que permite que
a execução de um algoritmo tome caminhos diferentes, dependendo da
entrada e dos dados já computados. Normalmente tem a forma <em>&quot;se Q,
então faça A, do contrário faça B&quot;</em>, ou apenas <em>&quot;se Q, então faça
A&quot;</em>. Nessas frases, Q é uma condição, ou uma pergunta, cuja a
resposta é sim ou não e pode ser testada por nosso robô.</p>
</li>
</ul>
<img src="figs/exit.jpg" style="width: 100%; max-width: 400px;">
<p>Você pode se perguntar como a execução de um algoritmo pode levar
tempo diferente se o tamanho do texto que o descreve é fixo. Se
tivéssemos apenas os tipos de controle acima, então toda execução
levaria o mesmo tempo. Para executarmos uma instrução ou um conjunto
de instruções por um número variável de vezes, precisamos das chamadas
<em>estruturas iterativas</em>. Cada parte da execução em que executamos esse
conjunto de instruções uma vez é chamada de <em>iteração</em>.</p>
<ul>
<li>
<p>A <strong>iteração limitada</strong> é a estrutura mais comum de iteração e é
normalmente da forma &quot;repita A exatamente N vezes&quot; ou muitas outras
vezes pode ser da forma &quot;para cada item I da lista L, faça A&quot;. Isso
foi útil, por exemplo, no exemplo da soma dos preços da lista de
compra, que vimos anteriormente.</p>
</li>
<li>
<p>A <strong>iteração condicional</strong> é outra estrutura de controle iterativa
que é utilizada quando não sabemos no início quantas vezes
precisamos iterar. Normalmente, tem as formas &quot;repita A até que Q
valha&quot; ou &quot;enquanto Q, faça A&quot;. De novo, Q é uma condição que pode
ser testada por nosso robô.</p>
</li>
</ul>
<p>As estruturas iterativas normalmente são chamadas de <strong>laços</strong> ou
<strong>loops</strong>.</p>
<p>Vamos reescrever o algoritmo para exemplo da lista de compras.
Nós vamos supor que nosso algoritmo recebe, não somente a lista
de compras, como o número de itens que ela contém, que representaremos
pela letra <code class="language-text">N</code>.</p>
<pre class="highlight">(1) tome nota do número zero; aponte para o primeiro item da lista;
(2) faça o seguinte N - 1 vezes:
    (2.1) adicione o valor do item atual ao número anotado;
    (2.2) aponte para o próximo item da lista;
(3) adicione o valor do item atual ao número anotado;
(4) devolva como saída o número anotado.
</pre><h2 id="combinando-estruturas">Combinando estruturas</h2>
<p>O que torna os algoritmos particularmente ricos é a possibilidade de
combinar as diversas estruturas de controle. Por exemplo, podemos
executar um laço dentro do conjunto de ações de uma estrutura
condicional. Mais do que isso, podemos executar um laço dentro do
conjunto de ações de outro laço. Nesse último exemplo, chamamos o
primeiro de <em>laço interno</em> e o segundo de <em>laço externo</em>. E assim por
diante!</p>
<p>Já deve dar para perceber que os algoritmos podem ficar cada vez mais
diversos e mas ricos — e, algumas vezes, mais complexos! Cada
algoritmo pode ser mais ou menos complicado. Isso vai depender do
problema que queremos resolver.</p>
<p>Vamos tentar fazer um algoritmo que ordena um conjunto de cartas!</p>
<img src="figs/bubble.svg" style="width: 100%; max-width: 400px; padding: 0 10%;">
<p>Uma maneira de fazer isso é primeiro colocar as cartas uma do lado da
outra. Depois, basta percorrer as cartas várias vezes, da esquerda
para a direita trocando cartas adjacentes que estejam fora de ordem.
Quando não encontrarmos nenhum par de cartas fora de ordem, sabemos
que as cartas estão ordenadas. Esse é um algoritmo chamado de <em>bubble
sort</em>, ou ordenação da bolha. A ideia é que as cartas maiores vão sendo
empurradas para o final, como se fossem bolhas.</p>
<img src="figs/bubble1.svg" style="width: 100%; max-width: 450px;">
<p>Na verdade, o bubblesort é um algoritmo bem lento e você ainda vai
aprender diversos algoritmos que são muitas vezes mais rápidos. Mas,
por enquanto, vamos nos concentrar em escrever esse algoritmo.
Primeiro, precisamos saber quantas vezes precisamos percorrer a
sequência de cartas. Na primeira vez que percorremos as cartas, deve
ser fácil convencer-se de que a maior carta estará no final. Na
segunda vez, a segunda maior carta já estará na posição correta, e
assim por diante. Assim, se o número de cartas é N, então basta
percorrer o baralho N - 1 vezes.</p>
<pre class="highlight">(1) repita o seguinte N − 1 vezes:
    (1.1) aponte para a primeira carta;
    (1.2) repita o seguinte N - 1 vezes:
        (1.2.1) compare a carta apontada atualmente com a seguinte;
        (1.2.2) se as cartas comparadas estão fora de ordem, inverta-as;
        (1.2.3) aponte para a próxima carta.
</pre><p>Esse é um exemplo de algoritmo em que utilizamos e combinamos
diversas estruturas de controle. Tente identificá-las!</p>
<h2 id="desenhando-um-algoritmo">Desenhando um algoritmo</h2>
<p>Ao invés de escrever um algoritmo, também podemos representá-los
utilizando desenhos. Há diversas maneiras de desenhá-los, mas talvez a
maneira mais comum é criar o que chamamos de &quot;diagrama de fluxo&quot;, ou
em inglês, &quot;flowchart&quot;.</p>
<p>Em um diagrama de fluxo, cada instrução elementar é representada por
um retângulo e cada desvio condicional é representado por um losango.
O objetivo é entender qual o <em>fluxo</em> de execução do algoritmo. Assim,
saindo de cada retângulo há um arco que aponta para a próxima
instrução a ser executada. Como a instrução executada depois de um
desvio condicional depende da resposta, sim ou não, a partir de um
losango há dois arcos, um para cada possibilidade.</p>
<p>Vamos tentar fazer um desenho do nosso algoritmo.</p>
<img src="figs/fluxo.svg" style="width: 100%; max-width: 500px;">
<p>Perceba que as estruturas iterativas correspondem ao desenho de um
ciclo no diagrama de fluxo. Isso explica a nomenclatura de laço.</p>
<h1 id="sub-rotinas">Sub-rotinas</h1>
<p>Algumas vezes, os algoritmos podem ficar mais e mais complicados.
Assim nossos algoritmo ou diagramas de fluxo podem ficar cada vez
maiores. Vamos ver um exemplo de como isso pode acontecer.</p>
<p>Suponha que, na nossa lista de compras, há, não somente o valor de cada
item, mas também o tipo. Assim, cada item pode ser <em>alimentação</em>,
<em>limpeza</em>, <em>vestuário</em>, <em>eletrônico</em> etc. Dependendo do supermercado a
que vamos, não vamos conseguir comprar todos os itens. Se no
supermercado mais próximo pudermos comprar apenas itens de alimentação
e limpeza, então precisamos saber o quanto vamos gastar com esses tipos
de item. Vamos modificar o algoritmo anterior.</p>
<pre class="highlight">(1) tome nota do número zero
(2) aponte para o primeiro item da lista;
(3) faça o seguinte N - 1 vezes:
    (3.1) se o item atual é do tipo &quot;alimentação&quot;
        (3.1.1) adicione o valor do item atual ao número anotado;
    (3.2) aponte para o próximo item da lista;
(4) se o item atual é do tipo &quot;alimentação&quot;
    (4.1) adicione o valor do item atual ao número anotado;
(5) aponte para o primeiro item da lista;
(6) faça o seguinte N - 1 vezes:
    (6.1) se o item atual é do tipo &quot;limpeza&quot;
        (6.1.1) adicione o valor do item atual ao número anotado;
    (6.2) aponte para o próximo item da lista;
(7) se o item atual é do tipo &quot;limpeza&quot;
    (7.1) adicione o valor do item atual ao número anotado;
(8) devolva como saída o número anotado.
</pre><p>É claro que há algoritmos mais simples para essa tarefa, mas esse
podemos fazer diversas observações do algoritmo que escrevemos acima.
Primeiro, o texto do algoritmo ficou muito maior. Mais importante do
que isso, é muito mais difícil entender o que está fazendo esse
algoritmo. Tente desenhar o diagrama de fluxo correspondente.</p>
<p>Além disso, observamos que há dois trechos do algoritmo que são muito
parecidos e tudo que muda é o tipo de alimento. Podemos então tentar
escrever esse trecho de código apenas uma vez utilizando um
<strong>parâmetro</strong> ao invés do tipo de alimento. Esse trecho de código é
chamado de <strong>sub-rotina</strong> ou <strong>procedimento</strong>.</p>
<pre class="highlight">SOMAR ITENS DA CATEGORIA (X)
(1) aponte para o primeiro item da lista;
(2) faça o seguinte N - 1 vezes:
    (2.1) se o item atual é do tipo X
        (2.1.1) adicione o valor do item atual ao número anotado;
    (2.2) aponte para o próximo item da lista;
(3) se o item atual é do tipo &quot;X&quot;
    (3.1) adicione o valor do item atual ao número anotado;
</pre><p>No texto acima, X é um parâmetro que será substituído pelo tipo de
alimento quando invocarmos essa sub-rotina. Com esse texto, agora
podemos <em>invocar</em> ou <em>chamar</em> a nossa sub-rotina duas vezes no
algoritmo principal.</p>
<pre class="highlight">(1) tome nota do número zero
(2) SOMAR ITENS DA CATEGORIA (&quot;alimentação&quot;)
(3) SOMAR ITENS DA CATEGORIA (&quot;limpeza&quot;)
(4) devolva como saída o número anotado.
</pre><p>Compare esse novo algoritmo com o algoritmo anterior. Ele não ficou
muito mais simples? É importante observar que agora utilizamos uma
instrução que antes não era permitida, que é SOMAR ITENS DA
CATEGORIA. Esta não é uma instrução elementar do nosso processador
original, mas utilizamos como se fosse. O que estamos fazendo é
análogo a ensinar o nosso robozinho a realizar uma nova atividade, de
forma que não precisamos explicar de novo como fazê-la. Dizemos que
estamos criando uma nova <em>abstração</em>, escondendo os detalhes de
implementação.</p>
<p>Podemos desenhar agora um diagrama de fluxo substituindo o trecho do
algoritmo da sub-rotina por um retângulo, como uma instrução
elementar. Faça isso.</p>
<h1 id="tipos-e-estrutura-de-de-dados">Tipos e estrutura de de dados</h1>
<p>Por enquanto falamos apenas de números anotados, de listas de itens de
compra, de apontamentos para itens, de ingredientes. Alguns desses
elementos aparecem na entrada e na saída, enquanto outros aparecem
como objetos intermediários computados durante a execução do
algoritmo. A todos esses objetos, chamaremos de <strong>dados</strong>.</p>
<h2 id="tipos">Tipos</h2>
<p>Os vários dados aparecem nos mais diversos sabores, ou mais
precisamente, nos mais diversos <strong>tipos</strong>. Os tipos mais comuns
utilizados nos computadores são os <em>números</em>, que podem ter diversos
subtipos, e <em>strings</em>, que representam palavras ou textos nos mais
diversos alfabetos.</p>
<p>Nos computadores que consideraremos, os dados são sempre representados
de alguma maneira em particular na memória do computador. Assim,
precisamos adotar convenções para representar os objetos tratados pelos
algoritmos como uma sequência bem definida de dados. Por exemplo,
enquanto tratamos números inteiros no formato decimal, a representação
desses números na memória é binária. Se quisermos representar objetos
mais complicados, como uma imagem, vamos precisar definir
representações apropriadas — algumas vezes um tanto quanto
complicadas, outras vezes mais simples.</p>
<p>É importante que entendamos exatamente qual é o tipo de cada dado que
tratamos no algoritmo, pois cada tipo permite operações distintas. Por
exemplo, podemos dividir dois números, mas não podemos dividir duas
strings!</p>
<h2 id="variaveis">Variáveis</h2>
<p>No algoritmo da soma, referimo-nos a um dado simplesmente como &quot;valor
anotado&quot;, que é inicializado com 0 e depois acumula o valor dos itens
de compra. O que estamos fazendo é utilizar uma <strong>variável</strong>. Uma
variável não é o valor de um dado em si; ao invés disso, podemos
entender uma variável como uma pequena caixa ou célula onde um
determinado <em>valor</em> pode ser armazenado. Cada variável tem um <em>tipo</em>
correspondente; assim, podemos imaginar que nessa caixa só cabem
valores do tipo correspondente.</p>
<p>Normalmente, damos um <em>nome</em> a essa caixa. Poderíamos, por exemplo, ao
invés de dizer &quot;número anotado&quot;, chamar essa variável de &quot;subtotal&quot;.</p>
<img src="figs/variavel.svg" style="width: 100%; max-width: 450px;">
<p>Em Computação, chamamos de variável uma célula que pode conter
diversos valores distintos em diferentes momentos, ao contrário da
Matemática, em que uma variável é apenas um símbolo que representa um
valor desconhecido.</p>
<p>Como o valor de uma variável pode mudar, necessitamos de instruções
específicas para alterar o valor de uma variável. Essa instrução é
chamada de <strong>atribuição</strong>. Normalmente escrevemos algo como &quot;Atribua
valor V à variável X&quot;, ou utilizamos uma notação mais simples, como X
$\gets$ V, que devemos ler como &quot;a variável X recebe o valor de V&quot;.</p>
<p>Também podemos atribuir um valor de uma expressão, como em X $\gets$
V+1, em que queremos atribuir à variável X o valor de V mais uma
unidade. Devemos tomar um cuidado especial, já que muitas vezes
o novo valor depende do valor anterior da variável. Assim, podemos
ter a instrução X $\gets$ X+1 que significa que o valor da variável
X deve ser mudado e que o novo valor é o valor anterior mais um.</p>
<h2 id="colecoes-de-dados">Coleções de dados</h2>
<p>Retomemos o exemplo da nossa lista de compras. Para representar a
entrada, falamos de uma &quot;lista de compras&quot;. Assim, cada item a ser
comprado é uma parte da lista. Podemos querer <strong>armazenar</strong> cada item
em um conjunto de variáveis. Por exemplo, o primeiro item na variável
X, o segundo na variável Y e o terceiro na variável Z. Mas logo você
deve perceber que essa estratégia não é boa se tivermos um lista de
compras com mais ou menos do que três itens. Para listas maiores,
precisaríamos definir mais variáveis e, para listas menores, teríamos
variáveis que não fazem sentido!</p>
<p>Como nosso objetivo é escrever um texto de tamanho fixo, mas que possa
ser executado com listas de qualquer tamanho, precisamos de uma maneira
de nos referir a esses elementos de maneira <em>uniforme</em>. Para isso,
vamos utilizar o que chamamos de <strong>lista</strong>. Dependendo do contexto, também
serão chamadas de <em>vetores</em> ou <em>arranjos unidimensionais</em>.</p>
<p>Para tomar um exemplo, vamos tentar representar a nossa sequência de
cartas usando uma lista. Por simplicidade, todas as cartas tem valores diferentes,
então vamos ignorar os naipes e supor que o ás é representado pelo número 1.
Assim, a sequência anterior poderia ser representada pela seguinte lista.</p>
<img src="figs/lista_cartas.svg" style="width: 100%; max-width: 350px;">
<p>Na figura acima, a variável <em>cartas</em> representa toda a sequência de
cartas, mas ainda precisamos de algum mecanismo para nos referir a
cada um dos elementos. Poderíamos dizer simplesmente &quot;o primeiro
elemento de cartas&quot;, mas há um jeito melhor. Vamos adotar uma notação
de colchetes, assim a primeira carta será <em>cartas[1]</em>, a segunda será
<em>cartas[2]</em> e assim por diante.</p>
<p>Com isso, podemos tentar reescrever nosso algoritmo bubblesort.</p>
<pre class="highlight">(1) repita o seguinte N − 1 vezes:
    (1.1) X &lt;-- 1;
    (1.2) enquanto X &lt; N
        (1.2.1) se cartas[X + 1] &lt; cartas[X], então inverta esses elementos;
        (1.2.3) X &lt;-- X + 1.
</pre>

        <!-- Navigation buttons -->
<div role="navigation" class="row justify-content-between">

  <div class="col-12 col-sm-5 col-lg-4">
    <a class="btn btn-primary w-100 mt-1 mt-sm-0" href="01-problemas-algoritmos.html">
      &larr; Anterior
    </a>
  </div>

  <div class="col-12 d-none d-lg-inline-block col-lg-4">
    <a class="btn btn-secondary w-100" href="../index.html">
      Voltar
    </a>
  </div>

  <div class="col-12 col-sm-5 col-lg-4">
    <a class="btn btn-primary w-100 mt-1 mt-sm-0" href="03-linguagens-programacao.html">
      Próxima &rarr;
    </a>
  </div>

</div>      </div>
    </div>
</article>

<hr />


<!-- Footer -->
<footer>
  <p class="copyright text-muted">
    <a href="https://www.ic.unicamp.br/~lehilton/" title="Página pessoal">
      Copyright &copy; 2020
    </a>
  </p>
</footer>
<!-- Bootstrap core JavaScript -->
<script src="../dist/vendor/jquery/jquery.min.js"></script>
<script src="../dist/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<!-- <script src="../dist/vendor/prism/prism.js"></script> -->

<!-- Custom scripts for this template -->
<script src="../dist/js/main.min.js"></script>

<!-- Mathjax setup -->
<script>
  MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
  };
</script>
<script src="../dist/vendor/mathjax/tex-chtml.js" id="MathJax-script" async></script>



  </body>

</html>