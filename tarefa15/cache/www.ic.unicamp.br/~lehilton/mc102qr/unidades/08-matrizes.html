<!DOCTYPE html>

<html lang="pt-br">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    Algoritmos e Programação de Computadores
    - Matrizes
  </title>

  <meta name="keywords" content="MC102, Algoritmos e Programação de Computadores, Python">
  <meta name="description" content="Página da disciplina de MC102 para turma QR">
  <meta name="author" content="Lehilton Pedrosa">

  <!-- Bootstrap core CSS -->
  <link href="../dist/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Theme css -->
  <link href="../dist/css/main.min.css" rel="stylesheet">

  <!-- Prism -->
  <!-- <link href="../dist/vendor/prism/prism.css" rel="stylesheet" /> -->
</head>
<body >

  <body>

<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="../index.html">MC102</a>


    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i>&#9776;</i>
    </button>

    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">

        <li class="nav-item top back-to-top-link">
          <a class="nav-link" href="#"><span class="glyphicon glyphicon-align-left" aria-hidden="true"></span>topo</a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="../index.html">voltar</a>
        </li>


      </ul>
    </div>
  </div>
</nav>

<!-- Page Header -->
<header class="masthead"   style="background-image: url('../images/home-bg.jpg')" >
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <div class="post-heading">

          <h1 >Matrizes</h1>


          <span class="meta">Quinta, 7 de maio de 2020</span>

        </div>
      </div>
    </div>
  </div>
</header>
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">


      <div class="col-lg-8 col-md-10 mx-auto">

        <p>Quando aprendemos listas, nossos exemplos todos tratavam de listas com
valores escalares. Dizemos que uma variável é de um tipo <strong>escalar</strong>
porque os valores possíveis são simples e indivisíveis, como um número
inteiro ou um número de ponto flutuante. Muitas vezes, também vamos
olhar para strings como uma unidade (sem se preocupar com quais partes
a formam), então também chamaremos as strings de valores escalares.</p>
<p>Restringir-nos a listas de valores escalares pode simplificar nossos
algoritmos, mas também limita o tipo de estrutura que conseguimos
representar. Para muitas aplicações, elas são tudo do que precisamos.</p>
<blockquote>
<p>Escreva um programa que leia as notas de 10 exercícios de um
estudante e calcule a média dos 9 exercícios com maiores notas.</p>
</blockquote>
<p>Esse problema é mais simples do que muitos outros que já fizemos, mas
vamos resolvê-lo agora com uma atenção especial à representação dos
dados. Queremos representar as notas de um aluno, então vamos
armazená-las em um lista de notas.</p>
<p>Em Python, os tipos das variáveis não estão anotadas juntamente com os
nomes das variáveis. Por isso, precisamos tomar bastante cuidado em
como nomeamos nossas variáveis, para ficar claro quando estamos
lidando com um valor escalar, ou com uma lista de escalares. Para
isso, devemos utilizar os nomes consistentemente:</p>
<ul>
<li>Uma nota é um escalar do tipo <code class="language-text">float</code>. Vamos denotar variáveis de
tipos <em>escalares</em> sempre pelo nome <strong><code class="language-text">nota</code></strong>.</li>
<li>Uma lista de notas é do tipo <code class="language-text">list</code> e cada elemento dessa lista é um
escalar que representa uma nota. Vamos denotar variáveis de tipo
<em>lista de escalares</em> sempre pelo nome <strong><code class="language-text">lista_notas</code></strong>.</li>
</ul>
<p>Uma vez que já sabemos como representar os dados na memória do
computador, já podemos passar a escrita do algoritmo. Você deve
escrever um algoritmo e construir o seu programa incrementalmente. Eu
vou adiantar tudo isso e mostrar o programa já pronto.</p>
<pre class="highlightlanguage-python">NUMERO_EXERCICIOS <span style="color: #666666">=</span> <span style="color: #666666">3</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ler_lista_notas</span>(n):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Devolve uma lista de n notas lidas do teclado&quot;&quot;&quot;</span>
    lista_notas <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Digite a próxima nota: &quot;</span>)
        nota <span style="color: #666666">=</span> <span style="color: #008000">float</span>(<span style="color: #008000">input</span>())
        lista_notas<span style="color: #666666">.</span>append(nota)
    <span style="color: #008000; font-weight: bold">return</span> lista_notas

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_media_excluida</span>(lista_notas, indice_excluida):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Devolve a média de lista_notas excluindo-se</span>
<span style="color: #BA2121; font-style: italic">    a nota de índice indice_excluida&quot;&quot;&quot;</span>
    soma <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">for</span> i, nota <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(lista_notas):
        <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">!=</span> indice_excluida:
            soma <span style="color: #666666">=</span> soma <span style="color: #666666">+</span> nota
    media <span style="color: #666666">=</span> soma <span style="color: #666666">/</span> (<span style="color: #008000">len</span>(lista_notas) <span style="color: #666666">-</span> <span style="color: #666666">1</span>)
    <span style="color: #008000; font-weight: bold">return</span> media

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">obter_indice_menor</span>(lista_notas):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Devolve o índice da menor nota&quot;&quot;&quot;</span>
    indice_menor <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    menor_nota <span style="color: #666666">=</span> lista_notas[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">for</span> i, nota <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(lista_notas):
        <span style="color: #008000; font-weight: bold">if</span> nota <span style="color: #666666">&lt;</span> menor_nota:
            menor_nota <span style="color: #666666">=</span> nota
            indice_menor <span style="color: #666666">=</span> i
    <span style="color: #008000; font-weight: bold">return</span> indice_menor

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Digite as notas dos exercícios:&quot;</span>)
    lista_notas <span style="color: #666666">=</span> ler_lista_notas(NUMERO_EXERCICIOS)
    indice_menor <span style="color: #666666">=</span> obter_indice_menor(lista_notas)
    media <span style="color: #666666">=</span> calcular_media_excluida(lista_notas, indice_menor)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;A média excluindo a pior nota é </span><span style="color: #BB6688; font-weight: bold">{media}</span><span style="color: #BA2121">&quot;</span>)

main()
</pre><p>Leia esse programa com atenção. Estude o que cada função faz. Não
continue lendo este texto até que tenha entendido e internalizado esse
programa.</p>
<p>É claro que uma professora não gostaria de usar esse programa, porque
ela não tem apenas um estudante. É bem possível que sua turma tenha
100 estudantes. Então ela teria que executar esse programa 100 vezes e
tomar nota manualmente da média de cada um. Pior, pode ser que a
professora decida que irá excluir a nota do <em>mesmo</em> exercício para a
turma inteira, então esse programa já não seria mais útil. Vejamos por
quê:</p>
<ol>
<li>
<p>para descobrir a média da turma, fixamos um exercício, e
percorremos a lista de notas de <strong>todos os estudantes</strong> para esse
exercício</p>
</li>
<li>
<p>para calcular a média de um estudante, fixamos esse estudante e
percorremos a lista de notas de <strong>todos os exercícios</strong> para esse
estudante</p>
</li>
</ol>
<p>Agora deve estar claro porque nos restringir a listas de escalares é
insuficiente: precisamos tanto da lista de notas de todos os
exercícios para um estudante, quanto da lista de notas de um exercício
para todos estudantes. Para deixar esse problema mais concreto, vamos
resolver o seguinte problema:</p>
<blockquote>
<p>Escreva um programa que leia a notas de 10 exercícios de 100
estudantes e depois:</p>
<ol>
<li>calcule a média da turma para cada exercício;</li>
<li>descubra o exercício com menor média da turma;</li>
<li>calcule a média de cada estudante, excluindo-se esse exercício.</li>
</ol>
</blockquote>
<p>Antes de começar a escrever nosso algoritmo e nosso programa,
precisamos pensar na maneira como vamos representar os dados na
memória. O que muda é que agora, além de representar as notas dos
exercícios de um estudantes, precisamos guardar a tabela de notas da
turma inteira. Vamos estender a nossa convenção:</p>
<ul>
<li>Uma nota é um escalar. Vamos denotar variáveis de tipos <em>escalares</em>
sempre pelo nome <strong><code class="language-text">nota</code></strong>.</li>
<li>Um estudante tem um lista de notas. Vamos denotar variáveis de tipo
<em>lista de escalares</em> sempre pelo nome <strong><code class="language-text">lista_notas</code></strong>;</li>
<li>A tabela de notas da turma é uma lista de lista de notas. Vamos
denotar variáveis de tipo <em>lista de lista de escalares</em> pelo nome
<strong><code class="language-text">tabela_notas</code></strong>.</li>
</ul>
<p>De novo, escrevemos um algoritmo e implementamos esse programa incrementalmente.
Vamos omitir esse processo e ver o resultado.</p>
<pre class="highlightlanguage-python">
NUMERO_EXERCICIOS <span style="color: #666666">=</span> <span style="color: #666666">10</span>
NUMERO_ESTUDANTES <span style="color: #666666">=</span> <span style="color: #666666">100</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ler_lista_notas</span>(n):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Devolve uma lista de n notas lidas do teclado&quot;&quot;&quot;</span>
    lista_notas <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Digite a próxima nota: &quot;</span>)
        nota <span style="color: #666666">=</span> <span style="color: #008000">float</span>(<span style="color: #008000">input</span>())
        lista_notas<span style="color: #666666">.</span>append(nota)
    <span style="color: #008000; font-weight: bold">return</span> lista_notas

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ler_tabela_notas</span>(m, n):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Devolve a tabela de notas de m estudantes</span>
<span style="color: #BA2121; font-style: italic">    com n notas de exercícios cada, lidas do teclado&quot;&quot;&quot;</span>
    tabela_notas <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Digite as notas dos exercicios do proximo estudante: &quot;</span>)
        lista_notas <span style="color: #666666">=</span> ler_lista_notas(n)
        tabela_notas<span style="color: #666666">.</span>append(lista_notas)
    <span style="color: #008000; font-weight: bold">return</span> tabela_notas

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_lista_medias</span>(tabela_notas):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Devolve uma lista com as médias dos exercício&quot;&quot;&quot;</span>
    m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tabela_notas)  <span style="color: #408080; font-style: italic"># número de estudantes</span>
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(tabela_notas[<span style="color: #666666">0</span>])  <span style="color: #408080; font-style: italic"># número de exercícios</span>

    lista_medias <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        soma <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
            soma <span style="color: #666666">=</span> soma <span style="color: #666666">+</span> tabela_notas[i][j]
        media <span style="color: #666666">=</span> soma <span style="color: #666666">/</span> m
        lista_medias<span style="color: #666666">.</span>append(media)

    <span style="color: #008000; font-weight: bold">return</span> lista_medias

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">obter_indice_menor</span>(lista_notas):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Devolve o índice da menor nota&quot;&quot;&quot;</span>
    indice_menor <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    menor_nota <span style="color: #666666">=</span> lista_notas[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">for</span> i, nota <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(lista_notas):
        <span style="color: #008000; font-weight: bold">if</span> nota <span style="color: #666666">&lt;</span> menor_nota:
            menor_nota <span style="color: #666666">=</span> nota
            indice_menor <span style="color: #666666">=</span> i
    <span style="color: #008000; font-weight: bold">return</span> indice_menor

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_media_excluida</span>(lista_notas, indice_excluida):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Devolve a média de lista_notas excluindo-se</span>
<span style="color: #BA2121; font-style: italic">    a nota de índice indice_excluida&quot;&quot;&quot;</span>
    soma <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">for</span> i, nota <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(lista_notas):
        <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">!=</span> indice_excluida:
            soma <span style="color: #666666">=</span> soma <span style="color: #666666">+</span> nota
    media <span style="color: #666666">=</span> soma <span style="color: #666666">/</span> (<span style="color: #008000">len</span>(lista_notas) <span style="color: #666666">-</span> <span style="color: #666666">1</span>)
    <span style="color: #008000; font-weight: bold">return</span> media

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    tabela_notas <span style="color: #666666">=</span> ler_tabela_notas(NUMERO_ESTUDANTES, NUMERO_EXERCICIOS)
    lista_medias <span style="color: #666666">=</span> calcular_lista_medias(tabela_notas)
    indice_menor <span style="color: #666666">=</span> obter_indice_menor(lista_medias)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NUMERO_ESTUDANTES):
        media <span style="color: #666666">=</span> calcular_media_excluida(tabela_notas[i], indice_menor)
        <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;O estudante </span><span style="color: #BB6688; font-weight: bold">{i}</span><span style="color: #BA2121"> tem média </span><span style="color: #BB6688; font-weight: bold">{media}</span><span style="color: #BA2121">&quot;</span>)

main()
</pre><p>Mantivemos as três funções do programa anterior. Ser organizado e usar
nomes de funções e variáveis consistentes realmente salva a vida!
Vamos estudar então as demais funções, a começar pela
<code class="language-text">ler_tabela_notas</code>.</p>
<p>Repare que função <code class="language-text">ler_tabela_notas</code> é surpreendente parecida com a
função <code class="language-text">ler_lista_notas</code>. Isso não acontece por um acaso. O que
<code class="language-text">ler_lista_notas</code> faz é construir e devolver uma lista de elementos,
cada um do tipo <code class="language-text">float</code>. Do mesmo modo, <code class="language-text">ler_tabela_notas</code> constrói e
devolve uma lista de elementos, mas dessa vez, cada elemento da lista
é uma outra lista.</p>
<p>Agora investiguemos <code class="language-text">calcular_lista_medias</code>. Essa função tem dois
laços aninhados. O <code class="language-text">for</code> externo pode ser lido como <em>para cada
exercício <code class="language-text">j</code>, calcule a média da turma para esse exercício</em>. Então
vamos nos concentrar em como calcular a média de um exercício. Já
vimos como calcular a média de uma lista de <code class="language-text">float</code>s antes; aqui,
queremos fazer algo parecido. A diferença é que as notas de um
exercício em particular estão espalhadas nas várias listas dos alunos.
Assim, primeiro precisamos acessar a lista de notas de um aluno, por
isso escrevemos <code class="language-text">tabela_notas[i]</code>. Depois, nesta lista, precisamos
acessar a nota do exercício <code class="language-text">j</code>, então escrevemos
<code class="language-text">tabela_notas[i][j]</code>. Respire um pouco e releia essa função. Agora
deve fazer sentido.</p>
<p>Por último, vamos olhar para a função <code class="language-text">main</code>. As instruções dela já
devem ser autoexplicativas (repararam que ela não tem comentários?).
Vamos olhar apenas para a chamada à função <code class="language-text">calcular_media_excluida</code>.
Essa função recebe como primeiro parâmetro uma lista de notas. De
fato, é exatamente isso que passamos a ela: <code class="language-text">tabela_notas[i]</code> é a
lista de notas do estudante de índice <code class="language-text">i</code>. Se você se sentir mais
confortável, poderia substituir essa linha pelas linhas abaixo. É
completamente equivalente!</p>
<pre class="highlightlanguage-python">        lista_notas <span style="color: #666666">=</span> tabela_notas[i]
        media <span style="color: #666666">=</span> calcular_media_excluida(lista_notas, indice_menor)
</pre><p>Agora que já entendeu o programa acima, execute-o e teste-o. Eu se
fosse você modificaria os valores de <code class="language-text">NUMERO_EXERCICIOS</code> e
<code class="language-text">NUMERO_ESTUDANTES</code> e criaria alguns arquivos de teste. Reflita sobre
testes automatizados.</p>
<h1 id="matrizes">Matrizes</h1>
<p>A principal estrutura de dados que criamos no exemplo anterior foi uma
lista de lista de escalares! Se quisermos, podemos escrever a nossa
tabela de notas como uma tabela de fato. A variável a seguir
representa três alunos, cada aluno tem quatro notas.</p>
<pre class="highlightlanguage-pycon"><span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>tabela_notas <span style="color: #666666">=</span> [
<span style="color: #000080; font-weight: bold">... </span>  [<span style="color: #666666">4.5</span>, <span style="color: #666666">7.6</span>, <span style="color: #666666">8.5</span>, <span style="color: #666666">4.5</span>],
<span style="color: #000080; font-weight: bold">... </span>  [<span style="color: #666666">9.9</span>, <span style="color: #666666">8.0</span>, <span style="color: #666666">8.0</span>, <span style="color: #666666">6.0</span>],
<span style="color: #000080; font-weight: bold">... </span>  [<span style="color: #666666">0.0</span>, <span style="color: #666666">3.3</span>, <span style="color: #666666">7.0</span>, <span style="color: #666666">8.0</span>],
<span style="color: #000080; font-weight: bold">... </span>]
</pre><p>Certa uniformidade é relevante. Repare que <code class="language-text">tabela_notas</code> é uma lista
com três listas, cada uma delas com quatro números do tipo <code class="language-text">float</code>.
Uma tabela como essa é normalmente chamada de <strong>matriz</strong> na
Matemática. Em Python, representamos matrizes usando lista de listas.
Na verdade, Python não sabe nada sobre matrizes, então poderíamos
escrever algo como</p>
<pre class="highlightlanguage-pycon"><span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>destabela_notas <span style="color: #666666">=</span> [
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>  [<span style="color: #666666">4.5</span>, <span style="color: #666666">4.5</span>],
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>  [<span style="color: #666666">9.9</span>, <span style="color: #666666">8.0</span>, <span style="color: #666666">8.0</span>, <span style="color: #666666">6.0</span>],
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>  [<span style="color: #BA2121">&quot;zero&quot;</span>, <span style="color: #666666">3</span>],
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>]
</pre><p>que o interpretador iria executar, indiferente ao sofrimento dos
obsessivos-compulsivos. Então devemos definir matriz de um jeito um
pouco mais preciso. Uma <strong>matriz</strong> é uma lista de listas tal que:</p>
<ol>
<li>todas as listas internas têm o mesmo número de elementos;</li>
<li>todos os elementos têm o mesmo tipo escalar.</li>
</ol>
<p>Algumas vezes, também chamamos listas de <strong>arranjos</strong>, do inglês
<em>arrays</em> (ou <strong>vetores</strong>, a depender da linguagem). Assim, podemos
dizer que uma matriz é um arranjo bidimensional. Também podemos
definir arranjos multidimensionais, embora eles sejam menos comuns. Se
temos dois estudantes, cada estudante fez três provas e cada prova tem
duas questões, então podemos representar as notas das questões como:</p>
<pre class="highlightlanguage-python"><span style="color: #666666">&gt;&gt;&gt;</span> notas_questoes <span style="color: #666666">=</span> [
<span style="color: #666666">...</span>   [[<span style="color: #666666">4.0</span>, <span style="color: #666666">5.0</span>],  [<span style="color: #666666">3.5</span>, <span style="color: #666666">5.0</span>],  [<span style="color: #666666">4.5</span>, <span style="color: #666666">4.0</span>]],
<span style="color: #666666">...</span>   [[<span style="color: #666666">3.0</span>, <span style="color: #666666">2.0</span>],  [<span style="color: #666666">2.5</span>, <span style="color: #666666">0.0</span>],  [<span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>]],
<span style="color: #666666">...</span> ]
</pre><p>Uma variável só é útil quando acessamos o seu valor. Para isso,
basta acessar uma lista de cada vez:</p>
<pre class="highlightlanguage-python"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># nota do segundo exercício do primeiro estudante</span>
<span style="color: #666666">&gt;&gt;&gt;</span> tabela_notas[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]
<span style="color: #666666">7.6</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># nota da primeira questão da segunda prova do segundo estudante</span>
<span style="color: #666666">&gt;&gt;&gt;</span> notas_questoes[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]
<span style="color: #666666">2.5</span>
</pre><h2 id="operacoes-em-matrizes">Operações em matrizes</h2>
<p>Na Álgebra Linear é comum realizar operações com matrizes, como soma,
produto por escalar, produto de matrizes, etc. Como Python não entende
o conceito de matriz, tampouco entende como realizar essas operações.
Por isso, temos de implementar cada uma delas. Vamos implementar
a operação de soma e fazer uma função para testá-la.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">somar_matrizes</span>(a, b):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Devolve a soma das matrizes a e b&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(a) <span style="color: #666666">==</span> <span style="color: #008000">len</span>(b), <span style="color: #BA2121">&quot;Números de linhas devem ser iguais&quot;</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(a[<span style="color: #666666">0</span>]) <span style="color: #666666">==</span> <span style="color: #008000">len</span>(b[<span style="color: #666666">0</span>]), <span style="color: #BA2121">&quot;Números de colunas devem ser iguais&quot;</span>

    m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(a)
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(a[<span style="color: #666666">0</span>])

    soma <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
        linha <span style="color: #666666">=</span> []
        soma<span style="color: #666666">.</span>append(linha)
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
            celula <span style="color: #666666">=</span> a[i][j] <span style="color: #666666">+</span> b[i][j]
            linha<span style="color: #666666">.</span>append(celula)
    <span style="color: #008000; font-weight: bold">return</span> soma

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    a <span style="color: #666666">=</span> [
      [<span style="color: #666666">5.3</span>, <span style="color: #666666">4.0</span>, <span style="color: #666666">7.5</span>],
      [<span style="color: #666666">9.0</span>, <span style="color: #666666">0.0</span>, <span style="color: #666666">9.5</span>],
      [<span style="color: #666666">7.0</span>, <span style="color: #666666">6.9</span>, <span style="color: #666666">7.8</span>]
    ]
    b <span style="color: #666666">=</span> [
      [<span style="color: #666666">1.0</span>, <span style="color: #666666">1.0</span>, <span style="color: #666666">1.0</span>],
      [<span style="color: #666666">1.0</span>, <span style="color: #666666">1.0</span>, <span style="color: #666666">1.0</span>],
      [<span style="color: #666666">1.0</span>, <span style="color: #666666">1.0</span>, <span style="color: #666666">1.0</span>]
    ]
    soma <span style="color: #666666">=</span> somar_matrizes(a, b)
    <span style="color: #008000">print</span>(soma)

main()
</pre><p>Na função <code class="language-text">somar_matrizes</code> decidimos criar a matriz <code class="language-text">soma</code> linha por
linha. Repare que adicionamos <code class="language-text">linha</code> à matriz <code class="language-text">soma</code> antes mesmo de
adicionar as células que irão compor essa linha. Poderíamos adicionar
a linha somente depois, é indiferente.</p>
<p>Para entender essa função, é útil simular e olhar para a representação
em memória. A figura a seguir mostra a memória do programa ao executar
a função <code class="language-text">somar_matrizes</code> durante a iteração <code class="language-text">i = 1</code> do laço externo e ao final
da iteração <code class="language-text">j = 0</code> do laço interno.</p>
<img src="figs/somar_matrizes.png" style="width: 100%; max-width: 500px;">
<p>Agora vamos começar a implementar o produto de matrizes. Para isso,
vamos relembrar. O produto de uma matriz $A$ de dimensões $m \times l$
por uma matriz $B$ de dimensões $l \times n$ é a matriz $C$ de
dimensões $m \times n$, denotada como</p>
<p>$$
C = A \times B
$$</p>
<p>em que um elemento $c_{ij}$ é definido pelo produto interno</p>
<p>$$
c_{ij} = \text{(linha $i$ de $A$)} \cdot \text{(coluna $j$ de $B$)}.
$$</p>
<p>Dessa vez, vamos primeiro criar uma matriz com zeros $C$ de dimensões
$m \times n$ e depois preenchê-la com os valores corretos.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">multiplicar_matrizes</span>(A, B):
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">len</span>(A[<span style="color: #666666">0</span>]) <span style="color: #666666">==</span> <span style="color: #008000">len</span>(B), <span style="color: #BA2121">&quot;Matrizes devem ser compatíveis&quot;</span>
    m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(A)
    l <span style="color: #666666">=</span> <span style="color: #008000">len</span>(B)
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(B[<span style="color: #666666">0</span>])
    C <span style="color: #666666">=</span> [[<span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n)] <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m)]
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
            C[i][j] <span style="color: #666666">=</span> calcular_produto_interno(A, B, i, j)
    <span style="color: #008000; font-weight: bold">return</span> C
</pre><p>Leia com atenção, faça um desenho da memória e complete a função
implementando <code class="language-text">calcular_produto_interno</code>.</p>
<h2 id="representacao-de-matrizes">Representação de matrizes</h2>
<p>Você deve ter percebido que alguns nomes de variáveis são recorrentes.
Isso é intencional para manter a consistência com a notação normalmente
utilizada em Álgebra Linear. Assim,</p>
<ul>
<li>as matrizes têm dimensão $m \times n$, ou seja, $m$ linhas e $n$ colunas;</li>
<li>os índices das linhas são normalmente denotados pela letra $i$;</li>
<li>os índices das colunas são normalmente denotados pela letra $j$.</li>
</ul>
<p>Enquanto essa convenção é puramente cosmética, utilizar sempre essa
notação pode evitar confusões que levam a um grande perda de tempo.</p>
<p>Há uma outra convenção que adotamos quando decidimos representar
matrizes: representamos uma matriz como uma <em>lista de linhas</em>. Dessa
vez, essa convenção não é meramente cosmética e tem consequências para
a forma com que você acessa os elementos de uma matriz e para a
maneira com que seu algoritmo manipula a matriz. Não impede que você
represente uma matriz como uma <em>lista de colunas</em>, mas só faça isso se
tiver uma justificativa.</p>
<p>Uma última palavrinha sobre matrizes em Python: elas não foram feitas
pensando em manipular grandes volumes de dados numéricos, nem para
realizar operações algébricas facilmente. Por esse motivo, quando
precisamos de fato manipular e realizar operações sobre matrizes,
normalmente utilizamos uma biblioteca. A mais popular para essa
finalidade é a <a href="https://numpy.org/">NumPy</a>. Nesta disciplina não
iremos utilizá-la, já que para isso seria necessário entender bem
programação orientada a objetos (o que não faremos!). Por isso, a não
ser que você precise, deixe para estudar essa e outras bibliotecas
mais tarde.</p>
<h1 id="arquivos">Arquivos</h1>
<p>Agora que já sabemos trabalhar com coleções de dados um pouco mais
complexas do que listas de números ou listas de strings, deve ficar
mais latente a necessidade de armazenar dados de maneira permanente. A
estratégia de sempre digitar os dados pelo teclado não funciona.
Assim, queremos distinguir a memória do computador em</p>
<ol>
<li>
<p><strong>Memória volátil</strong>. É a memória RAM, utilizada para armazenar
variáveis durante a execução do programa. Como regra geral, devemos
carregar na memória (i.e., criar variáveis) apenas os dados
necessários para realizar a computação. Quando o programa termina,
o sistema operacional libera a memória utilizada para outros
programas, os dados que não forem armazenados serão perdidos.</p>
</li>
<li>
<p><strong>Memória persistente</strong>. É a memória dos discos rígidos, cartões de
memória e outros tipos de periféricos que mantém os dados mesmo
após o desligamento do computador. Queremos guardar os dados que
poderão ser lidos mesmo depois que o programa termina.</p>
</li>
</ol>
<p>Enquanto organizamos a memória RAM utilizando variáveis, a abstração
utilizada para organizar a memória persistente são os <strong>arquivos</strong>. Um
arquivo é uma <em>sequência de bytes</em>, armazenados em um dispositivo de
memória persistente (disco rígido, CD, fita de dados, USB-Drive etc.)
e acessados por meio de um <em>nome</em>.</p>
<p>Os arquivos são <em>identificados</em> por um nome, assim, cada nome deve
corresponder a um único arquivo. Normalmente, o nome contém um sufixo,
chamado de <em>extensão</em> que correspondente ao tipo dos dados
armazenados no arquivo.</p>
<table>
<thead>
<tr>
<th align="left">Exemplo</th>
<th align="left">Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code class="language-text">arq.txt</code></td>
<td align="left">texto simples</td>
</tr>
<tr>
<td align="left"><code class="language-text">arq.svg</code></td>
<td align="left">imagem vetorial</td>
</tr>
<tr>
<td align="left"><code class="language-text">arq.c</code></td>
<td align="left">código-fonte em C</td>
</tr>
<tr>
<td align="left"><code class="language-text">arq.py</code></td>
<td align="left">código-fonte em Python</td>
</tr>
<tr>
<td align="left"><code class="language-text">arq.html</code></td>
<td align="left">página da Internet</td>
</tr>
<tr>
<td align="left"><code class="language-text">arq.exe</code></td>
<td align="left">executável</td>
</tr>
</tbody></table><p>Enquanto a extensão pode ser utilizada pelo sistema operacional para
classificar os arquivos, é importante saber que nada impede que
arquivos tenham conteúdo que não correspondem à extensão. Assim, um
arquivo <code class="language-text">arq.txt</code> pode ser o nome de um programa executável e assim
por diante.</p>
<p>Os arquivos são organizados no sistema de arquivo por meio de
<strong>diretórios</strong>. Um diretório é um arquivo especial que contém uma
lista de arquivos. Esses arquivos podem ser arquivos comuns ou outros
diretórios. Assim, os diretórios formam uma hierarquia.</p>
<p><img src="figs/hierarquia.png" alt="image" /></p>
<p>Todo programa executa a partir de algum diretório. Esse é o chamado
diretório de trabalho. Para saber qual é o diretório de trabalho em um
terminal, digit <code class="language-text">pwd</code> (ou <code class="language-text">cd</code> no Windows). Assim, para referenciar
outro arquivo, utilizamos o nome simples ou o nome completo na
hierarquia de diretórios, dependendo do diretório atual.</p>
<ul>
<li>
<p>Usamos barra <code class="language-text">/</code> para separar diretórios (ou contrabarra <code class="language-text">\</code> no
Windows)</p>
</li>
<li>
<p>Usamos uma única barra <code class="language-text">/</code> para representar a raiz da hierarquia</p>
</li>
</ul>
<p>Vejamos alguns exemplos de caminhos.</p>
<ul>
<li>
<p>Absolutos, a partir do diretório raiz:</p>
<pre class="highlight">/home/maria/imagem.jpg
/home/pedro/arquivo.txt
/home/pedro/mc102/lab.c
</pre></li>
<li>
<p>Relativo, a partir do diretório corrente (por exemplo, <code class="language-text">/home/pedro</code>):</p>
<pre class="highlight">../maria/imagem.jpg
arquivo.txt
mc102/lab.py
</pre></li>
</ul>
<p>Além da sequência de bytes, existem alguns dados associados a um
arquivo, que são chamados de atributos de arquivos, entre os quais o
proprietário do arquivo, as datas de criação, alteração e acesso, o
tamanho em bytes, permissões de acesso etc.</p>
<h2 id="arquivos-de-texto-e-arquivos-binarios">Arquivos de texto e arquivos binários</h2>
<p>Os arquivos podem ser classificados em dois grupos:</p>
<ol>
<li>Arquivos de texto</li>
<li>Arquivos binários</li>
</ol>
<img src="figs/arquivos.svg" style="width: 100%; max-width: 500px;">
<p>Um <strong>arquivo de texto</strong> é uma sequência de caracteres. Como no caso
das strings, cada caractere é representado por um ou mais bytes de
acordo com alguma tabela de codificação. A codificação mais comum nas
aplicações modernas é a chamada
<a href="https://pt.wikipedia.org/wiki/UTF-8">UTF-8</a>. Essa codificação
representa a tabela de caracteres
<a href="https://pt.wikipedia.org/wiki/Unicode">Unicode</a>, que contém
caracteres de quase todas as línguas, além de outros caracteres de
controle e, claro, emojis!</p>
<p>Você deveria salvar todos os seus arquivos de texto na codificação
UTF-8, mas pode ser que você precise lidar com outras codificações. O
importante é entender que arquivos de texto são representados em
alguma codificação e, se precisar ler um arquivo armazenado em uma
codificação diferente de sua aplicação, será necessário antes
converter esse arquivo.</p>
<p>Nem sempre é possível fazer essa conversão sem perda de informação,
sobretudo quando usamos aplicações legadas. Por exemplo, pode ser que
seu ambiente só reconheça a codificação
<a href="https://pt.wikipedia.org/wiki/ASCII">ASCII</a>, que não possui acentos
ou outros caracteres modificados. Pode ser que você tenha um conjunto
de arquivos de texto antigos e precise ler esses arquivos por um
programa em Python. Quase sempre é preciso se preocupar com a
codificação, ou dito de outra forma, quando ignoramos a codificação,
quase sempre as coisas vão dar errado.</p>
<p>Um <strong>arquivo binário</strong> é uma sequência qualquer de bytes. Lembre-se de
que um byte é uma sequência de 8 bits. Não podemos armazenar menos de
byte em um arquivo. Se você é atento, deverá ter percebido que um
arquivo de texto também é um arquivo binário! Na verdade, todos os
arquivos são binários, mas normalmente só chamamos de binários aqueles
cujos bytes não podem ser interpretados como um arquivo de texto. Isso
não significa que os bits e bytes não estejam organizados; significa
apenas que a organização do arquivo depende do formato.</p>
<p>Normalmente, mas nem sempre, os primeiros bytes dos arquivos
são suficientes para identificar qual é o formato do arquivo.
Por exemplo, o comando <code class="language-text">file</code> de sistemas Unix tenta
adivinhar o tipo dos dados de um arquivo, mesmo que a
extensão tenha sido modificada.</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/unidades$</span> file <span style="color: #666666">08</span>-matrizes.html
<span style="color: #888888">08-matrizes.html: HTML document, UTF-8 Unicode text, with very long lines</span>
<span style="color: #000080; font-weight: bold">user@notebook:~/unidades$</span> file virus.jpg
<span style="color: #888888">virus.jpg: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV)</span>
</pre><h2 id="manipulando-arquivos">Manipulando arquivos</h2>
<p><strong>Instruções</strong>: Para essa unidade, você deve ler a seção 7 sobre
entrada e saída e arquivos do
<a href="https://docs.python.org/pt-br/3/tutorial/index.html">tutorial</a>
Python.</p>
<p>Vamos resolver o seguinte exercício:</p>
<blockquote>
<p>Escreva um programa que leia um arquivo chamado <code class="language-text">&quot;palavras.txt&quot;</code> e
escreva as palavras que terminam com <code class="language-text">&quot;s&quot;</code> em um arquivo chamado
<code class="language-text">&quot;plurais.txt&quot;</code> e as demais em um arquivo chamado
<code class="language-text">&quot;singulares.txt&quot;</code>.</p>
</blockquote>
<h3 id="abrindo-e-fechando-arquivos">Abrindo e fechando arquivos</h3>
<p>Para acessar um arquivo, precisamos abrir esse arquivo usando uma
chamada <code class="language-text">open(nome_arquivo)</code>. Abrir um arquivo é um processo que
envolve diversas etapas. Por exemplo, o sistema operacional deve
verificar se o arquivo com o nome dado de fato existe e se o usuário
tem permissão de acesso a esse arquivo em particular, etc. Quando o
arquivo é aberto com sucesso, a função <code class="language-text">open</code> devolve uma variável com
metadados do arquivo. Em particular, essa variável contém um número
descritor do sistema operacional para o seu arquivo aberto.</p>
<pre class="highlightlanguage-pycon"><span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>arquivo <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&quot;palavras.txt&quot;</span>)
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>arquivo
<span style="color: #888888">&lt;_io.TextIOWrapper name=&#39;palavras.txt&#39; mode=&#39;r&#39; encoding=&#39;UTF-8&#39;&gt;</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>arquivo<span style="color: #666666">.</span>fileno()
<span style="color: #888888">3</span>
</pre><p>Uma vez terminado o acesso a um arquivo, é necessário fechá-lo. Fechar
um arquivo é muito importante, pois é nesse momento que salvamos as
eventuais alterações no disco (a tradução de <em>save</em> como <em>salvar</em> é
bastante infeliz, o que queremos fazer é guardar as alterações no
disco). Além disso, fechar um arquivo também pede ao sistema
operacional para liberar esse arquivo. Dependendo do sistema e do modo
como o arquivo foi aberto, outros programas ficaram impedidos de
manipular o arquivo enquanto ele não for fechado. Por isso, sempre
depois de trabalhar com um aquivo, chamamos a função <code class="language-text">close</code></p>
<pre class="highlightlanguage-python">arquivo <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&quot;palavras.txt&quot;</span>)
<span style="color: #408080; font-style: italic"># ...</span>
<span style="color: #408080; font-style: italic"># acessamos os dados do arquivo</span>
<span style="color: #408080; font-style: italic"># ...</span>
arquivo<span style="color: #666666">.</span>close()
</pre><p>Liberar um recurso depois de usado é tão importante que existe uma
sintaxe especial em Python para isso: o bloco <code class="language-text">with</code>. Assim, ao invés
de usar <code class="language-text">open</code> e <code class="language-text">close</code> como acima, sempre iremos escrever algo como</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&quot;palavras.txt&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> arquivo:
    <span style="color: #408080; font-style: italic"># ...</span>
    <span style="color: #408080; font-style: italic"># acessamos os dados do arquivo</span>
    <span style="color: #408080; font-style: italic"># ...</span>
</pre><p>Repare que o valor devolvido por <code class="language-text">open</code> é associado a <code class="language-text">arquivo</code>
e que não precisamos fechar o arquivo explicitamente.</p>
<h3 id="lendo-os-dados-do-arquivo">Lendo os dados do arquivo</h3>
<p>Quando abrimos um arquivo em um editor de texto, vemos um cursor
piscando. Esse cursor indica a posição de leitura e escrita atual do
arquivo. Do mesmo modo, quando abrimos um arquivo, o sistema
operacional cria um <strong>cursor de arquivo</strong>, que indica qual é a posição
atual do arquivo sendo acessado. O cursor é utilizado para informar a
posição no arquivo em estão os próximos bytes a serem lidos, ou a
posição no arquivo em que serão escritos os próximos bytes.</p>
<p>O acesso aos dados do arquivo pode se dar de dois modos:</p>
<ol>
<li>Sequencialmente, na ordem em que os dados foram armazenados.</li>
<li>Diretamente, obtendo diretamente o dado desejado a partir de sua posição.</li>
</ol>
<p>Quando lemos um arquivo sequencialmente, lemos cada byte do arquivo,
do primeiro ao último, assim como lemos um livro de literatura. No
acesso sequencial, o cursor de arquivo nunca retrocede. Quando
acessamos um arquivo diretamente, primeiros descobrimos em qual
posição está o dado requerido, assim como consultamos o índice de uma
lista telefônica. No acesso direto, posicionamos o cursor de arquivo
na posição do dado desejado. A cada operação de leitura ou escrita no
arquivo, o cursor move-se automaticamente para a próxima posição.</p>
<p>A maneira mais comum de ler um arquivo de dados é interpretar o arquivo
como um sequência de linhas e elr . Por esse motivo, Python permite
percorrer as linhas de um arquivo como se ele fosse uma lista de strings.</p>
<p>Vamos criar um arquivo de texto com os dados de uma estudante. Não é porque
o arquivo é de texto que ele não tem uma estrutura bem definida. No arquivo
seguinte, adotamos a seguinte convenção:</p>
<ol>
<li>a primeira linha contém o número de RA;</li>
<li>a segunda linha contém o nome completo;</li>
<li>a terceira linha contém a data de nascimento;</li>
<li>a quarta linha contém o nome da mãe.</li>
</ol>
<pre class="highlight">123456
 Ana Viva Mariana
29/2/2000
Maria Viva
</pre><p>Para ler esses dados, podemos fazer o seguinte</p>
<pre class="highlightlanguage-pycon"><span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span><span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&quot;dados.txt&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> arquivo:
<span style="color: #000080; font-weight: bold">... </span>    ra <span style="color: #666666">=</span> arquivo<span style="color: #666666">.</span>readline()
<span style="color: #000080; font-weight: bold">... </span>    nome_completo <span style="color: #666666">=</span> arquivo<span style="color: #666666">.</span>readline()
<span style="color: #000080; font-weight: bold">... </span>    nascimento <span style="color: #666666">=</span> arquivo<span style="color: #666666">.</span>readline()
<span style="color: #000080; font-weight: bold">... </span>    nome_mae <span style="color: #666666">=</span> arquivo<span style="color: #666666">.</span>readline()
<span style="color: #000080; font-weight: bold">...</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>ra
<span style="color: #888888">&#39; 123456\n&#39;</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>nome_completo
<span style="color: #888888">&#39; Ana Viva Mariana\n&#39;</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>nascimento
<span style="color: #888888">&#39;29/2/2000  \n&#39;</span>
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>nome_mae
<span style="color: #888888">&#39;Maria Viva&#39;</span>
</pre><p>Cada uma das variáveis lidas corresponde a uma linha e é do tipo
<code class="language-text">str</code>. Repare que todas as variáveis lidas terminam com um caractere
de nova linha <code class="language-text">\n</code>, com exceção da última. Isso ocorreu porque quando
criei esse arquivo não adicionei um caractere <code class="language-text">\n</code> na no fim do
arquivo, i.e., eu não &quot;dei enter&quot; após a última letra da última linha.</p>
<p>É prática comum terminar todas as linhas com <code class="language-text">\n</code>, tanto que muitas
vezes esse caractere é chamado de caractere de fim de linha. Sempre
adicione um caractere de fim de linha no final do seus arquivos de texto.</p>
<p>Observe também que <code class="language-text">nome_completo</code> começa com um espaço, assim como há
alguns espaços no final de <code class="language-text">nascimento</code>. Isso porque quando copiei o
arquivo em meu editor de texto adicionei alguns arquivos em branco.
Muitas vezes não vemos esses caracteres, então eles passam
desapercebidos. É uma boa prática não deixar esses caracteres no final
das linhas de seus arquivos de texto. Descubra como configurar seu
editor de texto.</p>
<p>Acontece que quando criamos um programa, não temos controle sobre os
arquivos que leremos. Então o que a maioria das programadoras faz é
livrar-se desses caracteres em branco. As strings em Python têm um
função para isso, <code class="language-text">strip</code>:</p>
<pre class="highlightlanguage-pycon"><span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>nome_completo<span style="color: #666666">.</span>strip()
<span style="color: #888888">&#39;Ana Viva Mariana&#39;</span>
</pre><p>Pode ser que você queira ler as linhas de um arquivo, mas não conheça
quantas linhas deverá ler até que o arquivo termine. Para isso, Python
permite percorrer as linhas do arquivo como se ele fosse uma lista de
strings — com a diferença crucial de que não podemos voltar nem acessar
uma linha com colchetes. Já podemos ler nosso arquivo de palavras.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ler_aquivo_palavras</span>(nome_arquivo):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Lê um arquivo e devolve a lista de palavras,</span>
<span style="color: #BA2121; font-style: italic">    uma por linha</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(nome_arquivo) <span style="color: #008000; font-weight: bold">as</span> arquivo:
        palavras <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> linha <span style="color: #AA22FF; font-weight: bold">in</span> arquivo:
            palavra <span style="color: #666666">=</span> linha<span style="color: #666666">.</span>strip()
            palavras<span style="color: #666666">.</span>append(palavra)

    <span style="color: #008000; font-weight: bold">return</span> palavras
</pre><p>Agora já podemos criar duas listas separadas, uma com as palavras
&quot;plurais&quot; e outras com as palavras &quot;singulares&quot; (é claro que isso não
é correto gramaticalmente, decidir se uma palavra está em plural é
muito mais desafiador do que simplesmente verificar se a última letra
é um &quot;s&quot;).</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">separar_plurais</span>(palavras):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Devolve a lista das palavras que terminam em s</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    plurais <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> palavra <span style="color: #AA22FF; font-weight: bold">in</span> palavras:
        <span style="color: #008000; font-weight: bold">if</span> palavra[<span style="color: #666666">-1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&quot;s&quot;</span>:
            plurais<span style="color: #666666">.</span>append(palavra)
    <span style="color: #008000; font-weight: bold">return</span> plurais

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">calcular_diferenca</span>(lista1, lista2):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Devolve uma lista com os elementos</span>
<span style="color: #BA2121; font-style: italic">    de lista1 que não estão em lista2</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    diferenca <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> valor <span style="color: #AA22FF; font-weight: bold">in</span> lista1:
        <span style="color: #008000; font-weight: bold">if</span> valor <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> lista2:
            diferenca<span style="color: #666666">.</span>append(valor)
    <span style="color: #008000; font-weight: bold">return</span> diferenca

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    palavras <span style="color: #666666">=</span> ler_aquivo_palavras(<span style="color: #BA2121">&quot;palavras.txt&quot;</span>)
    plurais <span style="color: #666666">=</span> separar_plurais(palavras)
    singulares <span style="color: #666666">=</span> calcular_diferenca(palavras, plurais)

    <span style="color: #008000">print</span>(plurais)
    <span style="color: #008000">print</span>(singulares)

    <span style="color: #408080; font-style: italic"># criar_arquivo_palavras(&quot;plural.txt&quot;, plurais)</span>
    <span style="color: #408080; font-style: italic"># criar_arquivo_palavras(&quot;singular.txt&quot;, singulares)</span>

main()
</pre><p>Isso deve ser suficiente para testar a leitura do arquivo. Experimente
com o arquivo seguinte.</p>
<pre class="highlight">feijão
arroz
limões
batata
beterrabas
pizzas
lasanha quatro-queijos
rapadura
</pre><h3 id="escrevendo-dados-em-um-arquivo">Escrevendo dados em um arquivo</h3>
<p>Para completar o nosso exercício, precisamos implementar a função
<code class="language-text">criar_arquivo_palavras(nome_arquivo, palavras)</code>, cujas chamadas estão
comentadas no trecho acima. O que essa função deve fazer é:</p>
<ol>
<li>criar um arquivo chamado <code class="language-text">nome_arquivo</code>;</li>
<li>escrever as palavras no arquivo, uma por linha.</li>
</ol>
<p>Quando chamamos <code class="language-text">open(&quot;palavras.txt&quot;)</code> acima, abrimos esse arquivo no
chamado modo de leitura. Para poder escrever em um arquivo, precisamos
abrir um aquivo no modo de escrita. Para isso faremos algo como
<code class="language-text">open(&quot;plurais.txt&quot;, &quot;w&quot;)</code>. Esse caractere <code class="language-text">&quot;w&quot;</code> está indicando que o
mode abertura do arquivo é de leitura. Quando não passamos esse
parâmetro, o padrão é modo de leitura, que também pode ser indicado
pelo caractere <code class="language-text">&quot;r&quot;</code>. Dependendo do objetivo, existem vários modos de
abertura de um arquivo, como os do exemplo abaixo. Mas os modos <code class="language-text">&quot;r&quot;</code>
e <code class="language-text">&quot;w&quot;</code> são os mais comuns.</p>
<table>
<thead>
<tr>
<th align="center"><strong>modo</strong></th>
<th align="left"><strong>operações</strong></th>
<th align="left"><strong>posição do cursor do arquivo</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code class="language-text">&quot;r&quot;</code></td>
<td align="left">leitura</td>
<td align="left">início</td>
</tr>
<tr>
<td align="center"><code class="language-text">&quot;r+&quot;</code></td>
<td align="left">leitura e escrita</td>
<td align="left">início</td>
</tr>
<tr>
<td align="center"><code class="language-text">&quot;w&quot;</code></td>
<td align="left">escrita</td>
<td align="left">início (trunca arquivo)</td>
</tr>
<tr>
<td align="center"><code class="language-text">&quot;w+&quot;</code></td>
<td align="left">escrita e leitura</td>
<td align="left">início (trunca arquivo)</td>
</tr>
<tr>
<td align="center"><code class="language-text">&quot;a&quot;</code></td>
<td align="left">escrita</td>
<td align="left">final</td>
</tr>
<tr>
<td align="center"><code class="language-text">&quot;a+&quot;</code></td>
<td align="left">leitura</td>
<td align="left">início</td>
</tr>
</tbody></table><p>O modo que iremos usar para nossa função é o <code class="language-text">&quot;w&quot;</code>, o que esse modo significa é o seguinte:</p>
<ol>
<li>se o arquivo sendo aberto não existir, então um aquivo com esse
nome é criado;</li>
<li>se um arquivo com esse nome existir, então esse arquivo é truncado
a 0 bytes, descartando quaisquer dados armazenados anteriormente;</li>
<li>o cursor de arquivo é posicionado em modo de escrita no início do
arquivo, que nesse momento está vazio.</li>
</ol>
<p>Tome cuidado ao usar o modo de escrita <code class="language-text">&quot;w&quot;</code>, já que ele pode levar a
perda de dados. Pode ser necessário verificar se o arquivo já existe,
ou renomeá-lo se já existir. Para isso, procure no módulo <code class="language-text">os</code> as
funções adequadas, como <code class="language-text">os.rename</code> ou <code class="language-text">os.remove</code>.</p>
<p>Para entender o significado de cada modo disponível, consulte a
documentação de <code class="language-text">open</code>. Aqui, só precisamos escrever uma linha por
vez. Fazemos isso com a função <code class="language-text">write</code>, que está disponível para os
arquivos.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">criar_arquivo_palavras</span>(nome_arquivo, palavras):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Cria um arquivo nome_arquivo com as palavras,</span>
<span style="color: #BA2121; font-style: italic">    uma por linha</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(nome_arquivo, <span style="color: #BA2121">&quot;w&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> arquivo:
        <span style="color: #008000; font-weight: bold">for</span> palavra <span style="color: #AA22FF; font-weight: bold">in</span> palavras:
            linha <span style="color: #666666">=</span> palavra <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>
            arquivo<span style="color: #666666">.</span>write(linha)
</pre><p>Repare que para escrever uma linha, precisamos adicionar uma quebra de
linha no final de cada linha manualmente. Se não fizermos isso, então
todas as palavras apareceriam coladas. Se preferir, também é possível
utilizar a função <code class="language-text">print</code>, que irá escrever no arquivo da mesma maneira
que escreveria na tela. A vantagem é que <code class="language-text">print</code> converte a variável para
uma string automaticamente.</p>
<pre class="highlightlanguage-pycon"><span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span>lista <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>]
<span style="color: #000080; font-weight: bold">&gt;&gt;&gt; </span><span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&quot;lista.txt&quot;</span>, <span style="color: #BA2121">&quot;w&quot;</span>) <span style="color: #008000; font-weight: bold">as</span> arquivo:
<span style="color: #000080; font-weight: bold">... </span>    <span style="color: #008000">print</span>(lista, file<span style="color: #666666">=</span>arquivo)
</pre><p>Experimente e descubra qual o conteúdo foi criado no arquivo
<code class="language-text">&quot;lista.txt&quot;</code>.</p>
<h3 id="entrada-e-saida-padrao">Entrada e saída padrão</h3>
<p>Quando vimos como abrir arquivos, aprendemos que uma variável do tipo
arquivo tem uma função <code class="language-text">fileno</code> que devolve um descritor do arquivo,
que é um número que designa um arquivo aberto de seu programa para o
sistema operacional. Se você executou o exemplo, é muito provável que
<code class="language-text">arquivo.fileno()</code> devolveu o mesmo número <code class="language-text">3</code> mostrado acima. Mas por
que o primeiro arquivo que abrimos tem descritor <code class="language-text">3</code>, e não <code class="language-text">0</code> ou
<code class="language-text">1</code>?</p>
<p>A resposta é que quando nossas instruções começam a executar, o processo
associado a nosso programa já tem três arquivos abertos. Esses arquivos
podem ser acessados a partir do módulo <code class="language-text">sys</code>, i.e, se escrevermos
<code class="language-text">import sys</code> no início do programa. São eles:</p>
<ul>
<li>A entrada padrão <code class="language-text">sys.stdin</code>, que tem descritor <code class="language-text">0</code>. Esse arquivo
começa aberto no modo de leitura e representa os dados digitados
pelo usuário. Normalmente acessamos esse arquivo através da função
<code class="language-text">input</code>.</li>
<li>A entrada padrão <code class="language-text">sys.stdout</code>, que tem descritor <code class="language-text">1</code>. Esse arquivo
começa aberto no modo de escrita e representa os dados mostrados na
tela. Normalmente acessamos esse arquivo através da função <code class="language-text">print</code>.</li>
<li>A entrada padrão <code class="language-text">sys.stderr</code>, que tem descritor <code class="language-text">2</code>. Esse arquivo
começa aberto no modo de escrita e representa as mensagens de erro
mostradas na tela. Normalmente acessamos esse arquivo através da
função <code class="language-text">print</code>, mas passando o parâmetro <code class="language-text">file=sys.stderr</code>.</li>
</ul>
<p>Nesta disciplina não usamos ainda mensagens de erro, mas elas podem
ser úteis para distinguir a saída do seu programa de uma mensagem,
particularmente uma mensagem de quando estamos testando o nosso
programa.</p>
<p>Entender e conhecer os arquivos de entrada e saída padrão é bastante
conveniente, particularmente quando nos cansarmos de testar nossos
programas digitando a entrada na mão, de novo e de novo. Em um terminal
podemos escrever</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook$</span> python3 programa.py &lt; entrada.txt &gt; saida.txt
</pre><p>Isso irá fazer com que <code class="language-text">sys.stdin</code> se refira ao arquivo <code class="language-text">entrada.txt</code>
e <code class="language-text">sys.stdout</code> se refira ao arquivo <code class="language-text">saida.txt</code>. Se também
quisermos guardar as mensagens de erro, poderíamos
escrever</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook$</span> python3 programa.py &lt; entrada.txt &gt; saida.txt <span style="color: #666666">2</span>&gt; erros.txt
</pre><p>mas é útil deixar que as mensagens de erro sejam mostradas na tela.
Vamos fazer isso em breve.</p>
<h1 id="um-exemplo-com-matrizes">Um exemplo com matrizes</h1>
<p>Vamos resolver o seguinte exercício:</p>
<blockquote>
<p>Escreva um programa que dada uma matriz de caracteres e uma palavra,
conte o número de vezes que a palavra aparece na matriz, tanto na
direção vertical quanto na horizontal.</p>
</blockquote>
<p>Vamos ver um exemplo.</p>
<pre class="highlight">OEAIAGBOOL
IIWAXHHLHN
PADUCAPNOC
ZBMOUIZSAS
OXEZOKOEUA
QCRMAAPAOH
DHOMEMTUFO
HOOAJCMVGM
NMFOANGMAE
JEVJVCCSNM
</pre><p>Se estivermos procurando <code class="language-text">HOMEM</code>, você deve encontrar duas ocorrências
dessa palavra na matriz acima.</p>
<p>Antes de tudo, precisamos formalizar o problema que nos é dado. O
enunciado não fala de onde essa matriz será obtida, nem de onde vamos
ler a palavra. Não é razoável digitar toda a matriz sempre que formos
testar nosso programa — acho que você deve concordar comigo, então não
devemos sequer cogitar testar esse programa digitando a entrada.</p>
<p>A solução agora deve ser evidente: vamos criar um arquivo para
armazenar a entrada de nosso programa. Nossa entrada é uma matriz de
caracteres e uma palavra, então é natural utilizarmos um arquivo de
texto. Precisamos de alguma convenção para organizar os dados no nosso
arquivo, assim definiremos a seguinte estrutura do arquivo, bem simples:</p>
<ul>
<li>a primeira linha contém a palavra sendo buscada;</li>
<li>as demais linhas contém as linhas da matriz, sem espaço entre os caracteres.</li>
</ul>
<p>Vamos criar um arquivo chamado <code class="language-text">caca_palavras.txt</code>.</p>
<pre class="highlight">HOMEM
OEAIAGBOOL
IIWAXHHLHN
PADUCAPNOC
ZBMOUIZSAS
OXEZOKOEUA
QCRMAAPAOH
DHOMEMTUFO
HOOAJCMVGM
NMFOANGMAE
JEVJVCCSNM
</pre><p>Enquanto esse exercício não é difícil, ele tampouco é trivial. Assim,
precisamos de método e organização, senão iremos gastar muito tempo
tentando resolvê-lo e a experiência de programação será frustrante.
Como sempre, vamos fazer uma lista de funções a serem implementadas e,
para cada uma delas, escrever um algoritmo em português antes de
programá-la. Precisamos de pelo menos duas funções, com os seguintes objetivos:</p>
<ol>
<li>ler um arquivo e devolver uma palavra e a matriz de caracteres;</li>
<li>procurar uma ocorrência de uma palavra na matriz.</li>
</ol>
<p>A primeira tarefa é mecânica: basta ler a primeira linha e depois
percorrer as demais linhas adicionado as palavras a uma lista.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ler_arquivo_entrada</span>(nome_arquivo):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Lê um arquivo com os dados de entrada</span>
<span style="color: #BA2121; font-style: italic">    e devolve a palavra e a matriz de caracteres&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(nome_arquivo) <span style="color: #008000; font-weight: bold">as</span> arquivo:
        palavra <span style="color: #666666">=</span> arquivo<span style="color: #666666">.</span>readline()<span style="color: #666666">.</span>strip()
        matriz <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> linha <span style="color: #AA22FF; font-weight: bold">in</span> arquivo:
            matriz<span style="color: #666666">.</span>append(linha<span style="color: #666666">.</span>strip())
    <span style="color: #008000; font-weight: bold">return</span> palavra, matriz
</pre><p>Representamos uma matriz de caracteres como uma lista de strings!
Assim, podemos acessar um caractere na linha <code class="language-text">i</code> e coluna <code class="language-text">j</code>
normalmente, digitando <code class="language-text">matriz[i][j]</code>. Enquanto isso é conveniente, há
uma consequência em termos de desempenho. Para acessar um elemento de
uma lista em uma posição <code class="language-text">j</code> dada, o interpretador Python pode acessar
essa posição na memória diretamente, isso é muito muito rápido.</p>
<p>Já para acessar um caractere de uma string em uma dada posição <code class="language-text">j</code>, é
necessário percorrer toda a string desde o início contando os
caracteres. Para strings pequenas como do nosso exemplo isso não é um
problema, mas para strings maiores ou para aplicações críticas, isso
pode ser extremamente ineficiente. Por sorte, é fácil corrigir esse
problema, basta converter a string em uma lista, mudando a iteração do
<code class="language-text">for</code> para <code class="language-text">matriz.append(list(linha.strip()))</code>. Sutil, mas
importante!</p>
<p>Para a segunda tarefa, queremos procurar as ocorrências de uma palavra
na matriz. Um algoritmo em alto nível, que é talvez o que a maioria
das pessoas faria, é o seguinte:</p>
<ul>
<li>
para cada linha $i$ da matriz<ul>
<li>
para cada coluna $j$ da matriz<ol>
<li>verifique se a palavra aparece horizontalmente a partir de $(i,j)$</li>
<li>verifique se a palavra aparece verticalmente a partir de $(i,j)$</li>
<li>atualize o contador de ocorrências</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>Agora escrevemos a função. Vamos postergar as tarefas mais difíceis
usando stubs.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">contar_ocorrencias</span>(palavra, matriz):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Conta o número de vezes que palavra</span>
<span style="color: #BA2121; font-style: italic">    ocorre em matriz, horizontal ou verticalmente&quot;&quot;&quot;</span>

    m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(matriz)
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(matriz[<span style="color: #666666">0</span>])

    ocorrencias <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
            <span style="color: #008000; font-weight: bold">if</span> ocorre_horizontal(palavra, matriz, i, j):
                ocorrencias <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">if</span> ocorre_vertical(palavra, matriz, i, j):
                ocorrencias <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> ocorrencias
</pre><p>Essa função não morde. Vamos passar à função <code class="language-text">main</code>.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    palavra, matriz <span style="color: #666666">=</span> ler_arquivo_entrada(<span style="color: #BA2121">&quot;caca_palavras.txt&quot;</span>)
    ocorrencias <span style="color: #666666">=</span> contar_ocorrencias(palavra, matriz)
    <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Há </span><span style="color: #BB6688; font-weight: bold">{ocorrencias}</span><span style="color: #BA2121"> ocorrencias&quot;</span>)
</pre><p>A mágica realmente acontece quando procuramos a ocorrência de uma
palavra. Vamos implementar <code class="language-text">ocorre_vertical</code>. Um algoritmo seria o
seguinte:</p>
<ol>
<li>$ocorre \gets True$</li>
<li>
para cada índice $k$ de $palavra$:<ul>
<li>compare os caracteres $palavra[k]$ com $matriz[i][j + k]$</li>
<li>se forem diferentes, faça $ocorre \gets False$</li>
</ul>
</li>
<li>devolva $ocorre$</li>
</ol>
<p>Isso verifica se cada caractere de palavra é corresponde a algum
caractere na linha $i$ da matriz começando pela coluna $j$.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ocorre_horizontal</span>(palavra, matriz, i, j):
    ocorre <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
    tamanho <span style="color: #666666">=</span> <span style="color: #008000">len</span>(palavra)
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(tamanho):
        <span style="color: #008000; font-weight: bold">if</span> palavra[k] <span style="color: #666666">!=</span> matriz[i][j <span style="color: #666666">+</span> k]:
            ocorre <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>
    <span style="color: #008000; font-weight: bold">return</span> ocorre

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ocorre_vertical</span>(palavra, matriz, i, j):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">False</span>
</pre><p>Juntamos todas as partes e executamos o nosso programa, digamos
<code class="language-text">caca_palavras.py</code>, apenas para descobrir que ele tem um erro.</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/matrizes$</span> python3 caca_palavras.py
<span style="color: #888888">Traceback (most recent call last):</span>
<span style="color: #888888">  File &quot;caca_palavras.py&quot;, line 46, in &lt;module&gt;</span>
<span style="color: #888888">    main()</span>
<span style="color: #888888">  File &quot;caca_palavras.py&quot;, line 43, in main</span>
<span style="color: #888888">    ocorrencias = contar_ocorrencias(palavra, matriz)</span>
<span style="color: #888888">  File &quot;caca_palavras.py&quot;, line 22, in contar_ocorrencias</span>
<span style="color: #888888">    if ocorre_horizontal(palavra, matriz, i, j):</span>
<span style="color: #888888">  File &quot;caca_palavras.py&quot;, line 33, in ocorre_horizontal</span>
<span style="color: #888888">    if palavra[k] != matriz[i][j + k]:</span>
<span style="color: #888888">IndexError: list index out of range</span>
</pre><p>Existe um erro ao acessar a coluna $j+k$ da linha $i$ da matriz. Para
poder corrigir esse erro, utilizamos um debugger, possivelmente
colocando configurando breakpoint na linha em que aconteceu o erro, ou
um pouco antes. Muitas vezes, é útil também colocar alguma mensagem de
debug. Para distinguir a mensagem de debug da saída normal do nosso
programa, vamos escrever no arquivo <code class="language-text">sys.stderr</code>, que é para onde esse
tipo de mensagem deve ir.</p>
<pre class="highlightlanguage-python"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>

<span style="color: #408080; font-style: italic"># ...</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ocorre_horizontal</span>(palavra, matriz, i, j):
    ocorre <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>
    tamanho <span style="color: #666666">=</span> <span style="color: #008000">len</span>(palavra)
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(tamanho):
        <span style="color: #008000">print</span>(<span style="color: #BA2121">f&quot;Comparando palavra[</span><span style="color: #BB6688; font-weight: bold">{k}</span><span style="color: #BA2121">] com matriz[</span><span style="color: #BB6688; font-weight: bold">{i}</span><span style="color: #BA2121">][{j + k}]&quot;</span>, file<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>stderr)
        <span style="color: #008000; font-weight: bold">if</span> palavra[k] <span style="color: #666666">==</span> matriz[i][j <span style="color: #666666">+</span> k]:
            ocorre <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">False</span>
    <span style="color: #008000; font-weight: bold">return</span> ocorre
</pre><p>Executando novamente, temos um bocado de informação na tela,
resumida a seguir:</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/matrizes$</span> python3 caca_palavras.py
<span style="color: #888888">Comparando palavra[0] com matriz[0][0]</span>
<span style="color: #888888">Comparando palavra[1] com matriz[0][1]</span>
<span style="color: #888888">Comparando palavra[2] com matriz[0][2]</span>
<span style="color: #888888">....</span>
<span style="color: #888888">Comparando palavra[0] com matriz[0][6]</span>
<span style="color: #888888">Comparando palavra[1] com matriz[0][7]</span>
<span style="color: #888888">Comparando palavra[2] com matriz[0][8]</span>
<span style="color: #888888">Comparando palavra[3] com matriz[0][9]</span>
<span style="color: #888888">Comparando palavra[4] com matriz[0][10]</span>
<span style="color: #888888">Traceback (most recent call last):</span>
<span style="color: #888888">  File &quot;caca_palavras.py&quot;, line 49, in &lt;module&gt;</span>
<span style="color: #888888">    main()</span>
<span style="color: #888888">  File &quot;caca_palavras.py&quot;, line 46, in main</span>
<span style="color: #888888">    ocorrencias = contar_ocorrencias(palavra, matriz)</span>
<span style="color: #888888">  File &quot;caca_palavras.py&quot;, line 24, in contar_ocorrencias</span>
<span style="color: #888888">    if ocorre_horizontal(palavra, matriz, i, j):</span>
<span style="color: #888888">  File &quot;caca_palavras.py&quot;, line 36, in ocorre_horizontal</span>
<span style="color: #888888">    if palavra[k] != matriz[i][j + k]:</span>
<span style="color: #888888">IndexError: list index out of range</span>
</pre><p>Se você contar, irá descobrir que a matriz tem apenas 10 colunas, mas
<code class="language-text">matriz[0][10]</code> se refere à décima-primeira coluna da primeira linha,
que não existe. Encontramos o erro. A vantagem de mostrar mensagens de
debug na saída de erro é que, enquanto escrevemos o programa, podemos
omitir essas mensagens, sem precisar remover as instruções do código.
Depois de modificada a função para tentar corrigir o erro, fazemos o
seguinte:</p>
<pre class="highlightlanguage-console"><span style="color: #000080; font-weight: bold">user@notebook:~/ra123456/matrizes$</span> python3 caca_palavras.py <span style="color: #666666">2</span>&gt; /dev/null
<span style="color: #888888">Há 1 ocorrencias</span>
</pre><p>Vemos somente a saída padrão. Nesse caso, eu executei o programa
depois de corrigir a função <code class="language-text">ocorre_horizontal</code>. Corrija essa função e
implemente a função que falta.</p>


        <!-- Navigation buttons -->
<div role="navigation" class="row justify-content-between">

  <div class="col-12 col-sm-5 col-lg-4">
    <a class="btn btn-primary w-100 mt-1 mt-sm-0" href="07-algortimos-iterativos.html">
      &larr; Anterior
    </a>
  </div>

  <div class="col-12 d-none d-lg-inline-block col-lg-4">
    <a class="btn btn-secondary w-100" href="../index.html">
      Voltar
    </a>
  </div>

  <div class="col-12 col-sm-5 col-lg-4">
    <a class="btn btn-primary w-100 mt-1 mt-sm-0" href="09-colecoes.html">
      Próxima &rarr;
    </a>
  </div>

</div>      </div>
    </div>
</article>

<hr />


<!-- Footer -->
<footer>
  <p class="copyright text-muted">
    <a href="https://www.ic.unicamp.br/~lehilton/" title="Página pessoal">
      Copyright &copy; 2020
    </a>
  </p>
</footer>
<!-- Bootstrap core JavaScript -->
<script src="../dist/vendor/jquery/jquery.min.js"></script>
<script src="../dist/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<!-- <script src="../dist/vendor/prism/prism.js"></script> -->

<!-- Custom scripts for this template -->
<script src="../dist/js/main.min.js"></script>

<!-- Mathjax setup -->
<script>
  MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
  };
</script>
<script src="../dist/vendor/mathjax/tex-chtml.js" id="MathJax-script" async></script>



  </body>

</html>